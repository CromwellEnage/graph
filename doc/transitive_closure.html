<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<!--
    Copyright (c) Jeremy Siek 2001

    Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
-->
<head>
<title>Boost Graph Library: Transitive Closure</title>
<link rel="stylesheet" type="text/css" href="graph.css" />
</head>
<body>
<img src="../../../boost.png" alt="C++ Boost" width="277" height="86" />

<br />

<h1><a name="sec:transitive_closure"></a><img src="figs/python.gif"
alt="(Python)" /><tt>transitive_closure</tt></h1>

<h3>Synopsis</h3>

<pre class="cxx_code">
template &lt;
    typename Graph, typename GraphTC, typename P, typename T, typename R
&gt;
void transitive_closure(const Graph&amp; g, GraphTC&amp; tc,
    const bgl_named_params&lt;P, T, R&gt;&amp; params = <span class="comment"
>/* all defaults */</span>);
</pre>

<p>If the configuration macro
<span class="cxx_code">BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS</span>
is defined, then the following function overload definition is available.</p>

<pre class="cxx_code">
<a href="../../parameter/doc/html/reference.html#boost-parameter-function-result-name-tag-namespace-arguments">BOOST_PARAMETER_FUNCTION</a>(
    (void), transitive_closure, ::boost::graph::keywords::tag,
    (required
        (graph
          , *(<span class="comment">/* unspecified predicate */</span>)
        )
    )
    (deduced
        (required
            (result
              , *(<span class="comment">/* unspecified predicate */</span>)
            )
        )
        (optional
            (vertex_index_map
              , *(<span class="comment">/* unspecified predicate */</span>)
              , <span class="comment"
>// see parameter table for default value</span>
            )
            (orig_to_copy
              , *(<span class="comment">/* unspecified predicate */</span>)
              , <span class="comment"
>// see parameter table for default value</span>
            )
        )
    )
)
</pre>

<p>If the configuration macro
<span class="cxx_code">BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS</span>
is <strong>not</strong> defined, then the following function overload
definition is available.</p>

<pre class="cxx_code">
template &lt;
    typename <a class="cxx_concept" href="Graph.html">Graph</a
>, typename GraphTC,
    typename G_to_TC_VertexMap, typename VertexIndexMap
&gt;
void transitive_closure(
    const Graph&amp; graph, GraphTC&amp; result,
    G_to_TC_VertexMap orig_to_copy, VertexIndexMap vertex_index_map
);
</pre>

<h3><a name="sec:description"></a>Description</h3>

<p>The transitive closure of a graph <i>G = (V,E)</i> is a graph <i>G* =
(V,E*)</i> such that <i>E*</i> contains an edge <i>(u,v)</i> if and only if
<i>G</i> contains a <a href="graph_theory_review.html#def:path">path</a> (of
at least one edge) from <i>u</i> to <i>v</i>.  The <span class="cxx_code"
>transitive_closure()</span> function transforms the input graph
<span class="cxx_code">graph</span> into the transitive closure graph
<span class="cxx_code">result</span>.</p>

<p>Thanks to Vladimir Prus for the implementation of this algorithm!</p>

<h3><a name="sec:where_defined"></a>Where Defined</h3>

<p><a href="../../../boost/graph/transitive_closure.hpp"
><tt>boost/graph/transitive_closure.hpp</tt></a></p>

<h3><a name="sec:parameters"></a>Parameters</h3>

<p>If <strong>any</strong> of the following are true:</p>

<ul>
<li>This document renders the category of a parameter as black text on a white
background.</li>
<li>The configuration macro <span
class="cxx_code">BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS</span> is
<strong>not</strong> defined.</li>
</ul>

<p>Then the argument must be bound to this parameter either by name or by
position.  On the other hand, if <strong>all</strong> of the following are
true:</p>

<ul>
<li>This document renders the category of a parameter as colored text on a
black background.</li>
<li>The configuration macro <span class="cxx_code"
>BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS</span> is defined.</li>
</ul>

<p>Then <a href="../../parameter/doc/html/index.html">Boost.Parameter's</a>
type deduction facilities can bind an unnamed argument to this parameter as
long as <strong>all</strong> of the following are true:</p>

<ul>
<li>The argument type fulfills the parameter type requirements.</li>
<li>The argument's position is the same as that of a parameter whose category
is rendered by this document such that the text is of the same color.</li>
</ul>

<table class="parameters">
<tr>
<th>Category:</th>
<td>IN</td>
</tr>
<tr>
<th><a href="../../parameter/doc/html/index.html">Boost.Parameter</a>
keyword:</th>
<td class="cxx_code">boost::graph::keywords::_graph</td>
</tr>
<tr>
<th>Unnamed version:</th>
<td class="cxx_code">const Graph&amp; graph</td>
</tr>
<tr>
<th>Description:</th>
<td>A directed graph.  Its type must be a model of <a class="cxx_concept"
href="VertexListGraph.html">Vertex List Graph</a>, <a class="cxx_concept"
href="AdjacencyGraph.html">Adjacency Graph</a>, and <a class="cxx_concept"
href="AdjacencyMatrix.html">Adjacency Matrix</a>.</td>
</tr>
<tr>
<th>Python:</th>
<td>The parameter is named <span class="python_code">graph</span>.</td>
</tr>
<tr>
<td colspan="2"><hr /></td>
</tr>
<tr class="deduced_param_0">
<th>Category:</th>
<td>OUT</td>
</tr>
<tr>
<th><a href="../../parameter/doc/html/index.html">Boost.Parameter</a>
keyword:</th>
<td class="cxx_code">boost::graph::keywords::_result</td>
</tr>
<tr>
<th>Unnamed version:</th>
<td class="cxx_code">GraphTC&amp; result</td>
</tr>
<tr>
<th>Description:</th>
<td>A directed graph.  Its type must be a model of <a class="cxx_concept"
href="VertexMutableGraph.html">Vertex Mutable Graph</a> and <a
class="cxx_concept" href="EdgeMutableGraph.html">Edge Mutable Graph</a>.</td>
</tr>
<tr>
<th>Python:</th>
<td>This parameter is not used in Python.  Instead, a new graph of the same
type is returned.</td>
</tr>
<tr>
<td colspan="2"><hr /></td>
</tr>
<tr class="deduced_param_0">
<th>Category:</th>
<td>UTIL/OUT</td>
</tr>
<tr>
<th><a href="../../parameter/doc/html/index.html">Boost.Parameter</a>
keyword:</th>
<td class="cxx_code">boost::graph::keywords::_orig_to_copy</td>
</tr>
<tr>
<th>Old-style signature:</th>
<td class="cxx_code">orig_to_copy(G_to_TC_VertexMap g_to_tc_map)</td>
</tr>
<tr>
<th>Description:</th>
<td>This maps each vertex in the input graph to the new matching vertices in
the output transitive closure graph.</td>
</tr>
<tr>
<th>Default:</th>
<td>An <a href="../../property_map/doc/iterator_property_map.html"
class="cxx_code">iterator_property_map</a> created from a <span
class="cxx_code"
>std::<a href="http://en.cppreference.com/w/cpp/container/vector">vector</a
></span> of the result graph's vertex descriptor type, and of size <span
class="cxx_code">num_vertices(graph)</span>, and using the index map argument
for the index map.</td>
</tr>
<tr>
<th>Python:</th>
<td>This must be a <span class="python_code">vertex_vertex_map</span> of the
graph.</td>
</tr>
<tr>
<td colspan="2"><hr /></td>
</tr>
<tr class="deduced_param_0">
<th>Category:</th>
<td>IN</td>
</tr>
<tr>
<th><a href="../../parameter/doc/html/index.html">Boost.Parameter</a>
keyword:</th>
<td class="cxx_code">boost::graph::keywords::_vertex_index_map</td>
</tr>
<tr>
<th>Old-style signature:</th>
<td class="cxx_code">vertex_index_map(VertexIndexMap i_map)</td>
</tr>
<tr>
<th>Description:</th>
<td>This maps each vertex to an integer in the range <tt>[0, <span
class="cxx_code">num_vertices(graph)</span>)</tt>.  The argument type must be
a model of <a href="../../property_map/doc/ReadablePropertyMap.html"
class="cxx_concept">Readable Property Map</a>.  The value type of the map must
be an integer type.  The vertex descriptor type of the graph needs to be
usable as the key type of the map.</td>
</tr>
<tr>
<th>Default:</th>
<td class="cxx_code">get(vertex_index, g)</td>
</tr>
<tr>
<th>Note:</th>
<td>If you use this default, make sure your graph has an internal <span
class="cxx_code">vertex_index</span> property.  For example, <span
class="cxx_code">adjacency_list</span> with <span class="cxx_code"
>VertexList=listS</span> does not have an internal <span class="cxx_code"
>vertex_index</span> property.</td>
</tr>
<tr>
<th>Python:</th>
<td>Unsupported parameter.</td>
</tr>
</table>

<h3><a name="sec:complexity"></a>Complexity</h3>

<p>The time complexity (worst-case) is <i>O(|V||E|)</i>.</p>

<h3><a name="sec:example"></a>Example</h3>

<p>The following is the graph from the example
<a href="../example/transitive_closure.cpp"><tt
>example/transitive_closure.cpp</tt></a> and the transitive closure computed
by the algorithm.</p>

<table>
<tr>
<td><img src="tc.gif" width="173" height="264" /></td>
<td><img src="tc-out.gif" width="200" height="360" /></td>
</tr>
</table>

<h3><a name="sec:notes"></a>Notes</h3>

<p>The algorithm used to implement the <span class="cxx_code"
>transitive_closure()</span> function is based on the detection of strong
components [<a href="bibliography.html#nuutila95">50</a>,
<a href="bibliography.html#purdom70">53</a>].  The following discussion
describes the algorithm (and some relevant background theory).</p>

<p>A <a name="def:successor-set"><i><b>successor set</b></i></a> of a vertex
<i>v</i>, denoted by <i>Succ(v)</i>, is the set of vertices that are
<a href="graph_theory_review.html#def:reachable">reachable</a> from vertex
<i>v</i>.  The set of vertices adjacent to <i>v</i> in the transitive closure
<i>G*</i> is the same as the successor set of <i>v</i> in the original graph
<i>G</i>.  Computing the transitive closure is equivalent to computing the
successor set for every vertex in <i>G</i>.</p>

<p>All vertices in the same strong component have the same successor set
(because every vertex is reachable from all the other vertices in the
component).  Therefore, it is redundant to compute the successor set for every
vertex in a strong component; it suffices to compute it for just one vertex
per component.</p>

<p>The following is the outline of the algorithm:</p>

<ol>
<li>Compute <a
href="strong_components.html#def:strongly-connected-component">strongly
connected components</a> of the graph.</li>
<li>Construct the condensation graph.  A <a name="def:condensation-graph"
><i><b>condensation graph</b></i></a> is a a graph <i>G'=(V',E')</i> based on
the graph <i>G=(V,E)</i> where each vertex in <i>V'</i> corresponds to a
strongly connected component in <i>G</i> and edge <i>(u,v)</i> is in <i>E'</i>
if and only if there exists an edge in <i>E</i> connecting any of the vertices
in the component of <i>u</i> to any of the vertices in the component of
<i>v</i>.</li>
<li>
<p>Compute transitive closure on the condensation graph.  This is done using
the following algorithm:</p>
<pre>
 for each vertex u in G' in reverse topological order
   for each vertex v in Adj[u]
     if (v not in Succ(u))
       Succ(u) = Succ(u) U { v } U Succ(v)   // &quot;U&quot; means set union
</pre>
<p>The vertices are considered in reverse topological order to ensure that the
when computing the successor set for a vertex <i>u</i>, the successor set for
each vertex in <i>Adj[u]</i> has already been computed.</p>
<p>An optimized implementation of the set union operation improves the
performance of the algorithm.  Therefore, this implementation uses
<a name="def:chain-decomposition"><i><b>chain decomposition</b></i></a> [<a
href="bibliography.html#goral79">51</a>, <a href="bibliography.html#simon86"
>52</a>].  The vertices of <i>G</i> are partitioned into chains
<i>Z<sub>1</sub>, ..., Z<sub>k</sub></i>, where each chain
<i>Z<sub>i</sub></i> is a path in <i>G</i> and the vertices in a chain have
increasing topological number.  A successor set <i>S</i> is then represented
by a collection of intersections with the chains, i.e., <i>S =
U<sub>i=1...k</sub> (Z<sub>i</sub> &amp; S)</i>.  Each intersection can be
represented by the first vertex in the path <i>Z<sub>i</sub></i> that is also
in <i>S</i>, since the rest of the path is guaranteed to also be in
<i>S</i>.  The collection of intersections is therefore represented by a
vector of length <i>k</i> where the ith element of the vector stores the first
vertex in the intersection of <i>S</i> with <i>Z<sub>i</sub></i>.</p>
<p>Computing the union of two successor sets, <i>S<sub>3</sub> = S<sub>1</sub>
U S<sub>2</sub></i>, can then be computed in <i>O(k)</i> time with the
following operation:</p>
<pre>
  for i = 0...k
    S3[i] = min(S1[i], S2[i])
    // where min compares the topological number of the vertices
</pre>
</li>
<li>Create the graph <i>G*</i> based on the transitive closure of the
condensation graph <i>G'*</i>.</li>
</ol>

<br />
<hr />
<table>
<tr>
<td class="copyright">Copyright &copy; 2000-2001</td>
<td><a href="http://www.boost.org/people/jeremy_siek.htm">Jeremy Siek</a>,
Indiana University
(<a class="external" href="mailto:jsiek@osl.iu.edu">jsiek@osl.iu.edu</a>)</td>
</tr>
</table>

</body>
</html> 
