<HTML>
<!--
     Copyright (c) Jeremy Siek 2000
    
     Distributed under the Boost Software License, Version 1.0.
     (See accompanying file LICENSE_1_0.txt or copy at
     http://www.boost.org/LICENSE_1_0.txt)
-->
<Head>
<Title>Boost Graph Library: Edmonds-Karp Maximum Flow</Title>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
        ALINK="#ff0000"> 
<IMG SRC="../../../boost.png" 
     ALT="C++ Boost" width="277" height="86"> 

<BR Clear>

<H1><A NAME="sec:edmonds_karp_max_flow">
<TT>edmonds_karp_max_flow</TT>
</H1>

<PRE>
<i>// Boost.Parameter-enabled version</i>
template &lt;
    typename <a href="./Graph.html">Graph</a>,
    typename TaggedArg0, typename TaggedArg1, ..., typename TaggedArg5
&gt;
typename boost::lazy_enable_if&lt;
    parameter::<a
href="../../parameter/doc/html/reference.html#are-tagged-arguments"
>are_tagged_arguments</a>&lt;
        TaggedArg0, TaggedArg1, ..., TaggedArg5
    &gt;,
    boost::detail::tagged_property_map_value&lt;
        boost::graph::keywords::tag::capacity_map, edge_capacity_t, Graph,
        TaggedArg0, TaggedArg1, ..., TaggedArg5
    &gt;
&gt;::type
edmonds_karp_max_flow(
    Graph&amp; g,
    typename <a href="graph_traits.html">graph_traits</a
>&lt;Graph&gt;::vertex_descriptor src,
    typename <a href="graph_traits.html">graph_traits</a
>&lt;Graph&gt;::vertex_descriptor sink,
    const TaggedArg0&amp; a0 = <i>unspecified</i>,
    const TaggedArg1&amp; a1 = <i>unspecified</i>,
    ...,
    const TaggedArg5&amp; a5 = <i>unspecified</i>
);

<i>// old-style named parameter version</i>
template &lt;class <a href="./Graph.html">Graph</a>, class P, class T, class R&gt;
typename boost::detail::edge_capacity_value&lt;Graph, P, T, R&gt;::value_type
edmonds_karp_max_flow(Graph&amp; g, 
   typename <a href="graph_traits.html">graph_traits</a
>&lt;Graph&gt;::vertex_descriptor src,
   typename <a href="graph_traits.html">graph_traits</a
>&lt;Graph&gt;::vertex_descriptor sink,
   const bgl_named_params&lt;P, T, R&gt;&amp; params = <i>all defaults</i>)

<i>// non-named parameter version</i>
template &lt;class <a href="./Graph.html">Graph</a>, 
	  class CapacityEdgeMap, class ResidualCapacityEdgeMap,
	  class ReverseEdgeMap, class ColorMap, class PredEdgeMap&gt;
typename property_traits&lt;CapacityEdgeMap&gt;::value_type
edmonds_karp_max_flow(Graph&amp; g, 
   typename <a href="graph_traits.html">graph_traits</a
>&lt;Graph&gt;::vertex_descriptor src,
   typename <a href="graph_traits.html">graph_traits</a
>&lt;Graph&gt;::vertex_descriptor sink,
   CapacityEdgeMap cap, ResidualCapacityEdgeMap res, ReverseEdgeMap rev, 
   ColorMap color, PredEdgeMap pred)
</PRE>

<P>
The <tt>edmonds_karp_max_flow()</tt> function calculates the maximum flow
of a network. See Section <a
href="./graph_theory_review.html#sec:network-flow-algorithms">Network
Flow Algorithms</a> for a description of maximum flow.  The calculated
maximum flow will be the return value of the function. The function
also calculates the flow values <i>f(u,v)</i> for all <i>(u,v)</i> in
<i>E</i>, which are returned in the form of the residual capacity
<i>r(u,v) = c(u,v) - f(u,v)</i>. 

<p>
There are several special requirements on the input graph and property
map parameters for this algorithm. First, the directed graph
<i>G=(V,E)</i> that represents the network must be augmented to
include the reverse edge for every edge in <i>E</i>.  That is, the
input graph should be <i>G<sub>in</sub> = (V,{E U
E<sup>T</sup>})</i>. The <tt>ReverseEdgeMap</tt> argument <tt>rev</tt>
must map each edge in the original graph to its reverse edge, that is
<i>(u,v) -> (v,u)</i> for all <i>(u,v)</i> in <i>E</i>. The
<tt>CapacityEdgeMap</tt> argument <tt>cap</tt> must map each edge in
<i>E</i> to a positive number, and each edge in <i>E<sup>T</sup></i>
to 0.

<p>
The algorithm is due to <a
href="./bibliography.html#edmonds72:_improvements_netflow">Edmonds and
Karp</a>, though we are using the variation called the ``labeling
algorithm'' described in <a
href="./bibliography.html#ahuja93:_network_flows">Network Flows</a>.

<p>
This algorithm provides a very simple and easy to implement solution to
the maximum flow problem. However, there are several reasons why this
algorithm is not as good as the <a
href="./push_relabel_max_flow.html"><tt>push_relabel_max_flow()</tt></a>
or the <a
href="./boykov_kolmogorov_max_flow.html"><tt>boykov_kolmogorov_max_flow()</tt></a>
algorithm.

<ul>
  <li>In the non-integer capacity case, the time complexity is <i>O(V
   E<sup>2</sup>)</i> which is worse than the time complexity of the
   push-relabel algorithm <i>O(V<sup>2</sup>E<sup>1/2</sup>)</i>
   for all but the sparsest of graphs.</li>

  <li>In the integer capacity case, if the capacity bound <i>U</i> is
    very large then the algorithm will take a long time.</li>
</ul>


<h3>Where Defined</h3>

<P>
<a href="../../../boost/graph/edmonds_karp_max_flow.hpp"><TT>boost/graph/edmonds_karp_max_flow.hpp</TT></a>
</P>

<h3>Parameters</h3>

<table>
<tr valign="top">
<th>Category:</th>
<td>IN</td>
</tr>
<tr valign="top">
<th>Signature:</th>
<td bgcolor="#dfdfdf"><tt>Graph&amp; g</tt></td>
</tr>
<tr valign="top">
<th>Description:</th>
<td>A directed graph.  Its type must be a model of <a
href="./VertexListGraph.html"><b>Vertex List Graph</b></a> and <a
href="./IncidenceGraph.html"><b>Incidence Graph</b></a>.  For each edge
<i>(u,v)</i> in the graph, the reverse edge <i>(v,u)</i> must also be in the
graph.</td>
</tr>
<tr>
<td colspan="2"><hr /></td>
</tr>
<tr valign="top">
<th>Category:</th>
<td>IN</td>
</tr>
<tr valign="top">
<th>Signature:</th>
<td bgcolor="#dfdfdf"><tt>typename <a href="graph_traits.html">graph_traits</a
>&lt;Graph&gt;::vertex_descriptor src</tt></td>
</tr>
<tr valign="top">
<th>Description:</th>
<td>The source vertex for the flow network graph.</td>
</tr>
<tr>
<td colspan="2"><hr /></td>
</tr>
<tr valign="top">
<th>Category:</th>
<td>IN</td>
</tr>
<tr valign="top">
<th>Signature:</th>
<td bgcolor="#dfdfdf"><tt>typename <a href="graph_traits.html">graph_traits</a
>&lt;Graph&gt;::vertex_descriptor sink</tt></td>
</tr>
<tr valign="top">
<th>Description:</th>
<td>The sink vertex for the flow network graph.</td>
</tr>
</table>

<h3>Named Parameters</h3>

<table>
<tr valign="top">
<th>Category:</th>
<td>IN</td>
</tr>
<tr valign="top">
<th><a href="../../parameter/doc/html/index.html">Boost.Parameter</a>
keyword:</th>
<td bgcolor="#dfdfdf"><tt>boost::graph::keywords::_capacity_map</tt></td>
</tr>
<tr valign="top">
<th>Old-style signature:</th>
<td bgcolor="#dfdfdf"><tt>capacity_map(CapacityEdgeMap cap)</tt></td>
</tr>
<tr valign="top">
<th>Description:</th>
<td>The edge capacity property map.  Its type must be a model of a constant <a
href="../../property_map/doc/LvaluePropertyMap.html"><b>Lvalue Property
Map</b></a>.  The key type of the map must be the graph's edge descriptor
type.</td>
</tr>
<tr valign="top">
<th>Default:</th>
<td bgcolor="#dfdfdf"><tt>get(edge_capacity, g)</tt></td>
</tr>
<tr>
<td colspan="2"><hr /></td>
</tr>
<tr valign="top">
<th>Category:</th>
<td>OUT</td>
</tr>
<tr valign="top">
<th><a href="../../parameter/doc/html/index.html">Boost.Parameter</a>
keyword:</th>
<td bgcolor="#dfdfdf"
><tt>boost::graph::keywords::_residual_capacity_map</tt></td>
</tr>
<tr valign="top">
<th>Old-style signature:</th>
<td bgcolor="#dfdfdf"><tt>residual_capacity_map(ResidualCapacityEdgeMap
res)</tt></td>
</tr>
<tr valign="top">
<th>Description:</th>
<td>The edge residual capacity property map.  Its type must be a model of a
mutable <a href="../../property_map/doc/LvaluePropertyMap.html"><b>Lvalue
Property Map</b></a>.  The key type of the map must be the graph's edge
descriptor type.</td>
</tr>
<tr valign="top">
<th>Default:</th>
<td bgcolor="#dfdfdf"><tt>get(edge_residual_capacity, g)</tt></td>
</tr>
<tr>
<td colspan="2"><hr /></td>
</tr>
<tr valign="top">
<th>Category:</th>
<td>IN</td>
</tr>
<tr valign="top">
<th><a href="../../parameter/doc/html/index.html">Boost.Parameter</a>
keyword:</th>
<td bgcolor="#dfdfdf"><tt>boost::graph::keywords::_reverse_edge_map</tt></td>
</tr>
<tr valign="top">
<th>Old-style signature:</th>
<td bgcolor="#dfdfdf"><tt>reverse_edge_map(ReverseEdgeMap rev)</tt></td>
</tr>
<tr valign="top">
<th>Description:</th>
<td>An edge property map that maps every edge <i>(u,v)</i> in the graph to the
reverse edge <i>(v,u)</i>.  Its type must be a model of a constant <a
href="../../property_map/doc/LvaluePropertyMap.html"><b>Lvalue Property
Map</b></a>.  The key type of the map must be the graph's edge descriptor
type.</td>
</tr>
<tr valign="top">
<th>Default:</th>
<td bgcolor="#dfdfdf"><tt>get(edge_reverse, g)</tt></td>
</tr>
<tr>
<td colspan="2"><hr /></td>
</tr>
<tr valign="top">
<th>Category:</th>
<td>UTIL</td>
</tr>
<tr valign="top">
<th><a href="../../parameter/doc/html/index.html">Boost.Parameter</a>
keyword:</th>
<td bgcolor="#dfdfdf"><tt>boost::graph::keywords::_predecessor_map</tt></td>
</tr>
<tr valign="top">
<th>Old-style signature:</th>
<td bgcolor="#dfdfdf"><tt>predecessor_map(PredEdgeMap p_map)</tt></td>
</tr>
<tr valign="top">
<th>Description:</th>
<td>Use by the algorithm to store augmenting paths.  The argument type must be
a mutable <a href="../../property_map/doc/LvaluePropertyMap.html"><b>Lvalue
Property Map</b></a>.  The key type must be the graph's vertex descriptor type
and the value type must be the graph's edge descriptor type.</td>
</tr>
<tr valign="top">
<th>Default:</th>
<td bgcolor="#dfdfdf">An <a
href="../../property_map/doc/iterator_property_map.html"><tt
>iterator_property_map</tt></a> created from a <tt>std::<a
href="http://en.cppreference.com/w/cpp/container/vector">vector</a></tt> of
edge descriptors, and of size <tt>num_vertices(g)</tt>, and using the index
map argument for the index map.</td>
</tr>
<tr>
<td colspan="2"><hr /></td>
</tr>
<tr valign="top">
<th>Category:</th>
<td>UTIL</td>
</tr>
<tr valign="top">
<th><a href="../../parameter/doc/html/index.html">Boost.Parameter</a>
keyword:</th>
<td bgcolor="#dfdfdf"><tt>boost::graph::keywords::_color_map</tt></td>
</tr>
<tr valign="top">
<th>Old-style signature:</th>
<td bgcolor="#dfdfdf"><tt>color_map(ColorMap c_map)</tt></td>
</tr>
<tr valign="top">
<th>Description:</th>
<td>Used by the algorithm to keep track of progress during the breadth-first
search stage.  At the end of the algorithm, the white vertices define the
minimum cut set.  The argument type must be a mutable <a
href="../../property_map/doc/LvaluePropertyMap.html"><b>Lvalue Property
Map</b></a>.  The key type of the map must be the graph's vertex descriptor
type, and the value type of the map must be a model of
<a href="./ColorValue.html"><b>Color Value</b></a>.</td>
</tr>
<tr valign="top">
<th>Default:</th>
<td bgcolor="#dfdfdf">An <a
href="../../property_map/doc/iterator_property_map.html"><tt
>iterator_property_map</tt></a> created from a <tt>std::<a
href="http://en.cppreference.com/w/cpp/container/vector">vector</a></tt> of
<tt>default_color_type</tt>, and of size <tt>num_vertices(g)</tt>, and using
the index map argument for the index map.</td>
</tr>
<tr>
<td colspan="2"><hr /></td>
</tr>
<tr valign="top">
<th>Category:</th>
<td>IN</td>
</tr>
<tr valign="top">
<th><a href="../../parameter/doc/html/index.html">Boost.Parameter</a>
keyword:</th>
<td bgcolor="#dfdfdf"><tt>boost::graph::keywords::_vertex_index_map</tt></td>
</tr>
<tr valign="top">
<th>Old-style signature:</th>
<td bgcolor="#dfdfdf"><tt>vertex_index_map(VertexIndexMap i_map)</tt></td>
</tr>
<tr valign="top">
<th>Description:</th>
<td>This maps each vertex of the graph to a unique integer in the range
<tt>[0, num_vertices(g))</tt>.  The argument type must be a model of <a
href="../../property_map/doc/ReadablePropertyMap.html"><b>Readable Property
Map</b></a>.  The key type of the map must be the graph's vertex descriptor
type.</td>
</tr>
<tr valign="top">
<th>Default:</th>
<td bgcolor="#dfdfdf"><tt>get(vertex_index, g)</tt><br />Note: if you use this
default, make sure your graph has an internal <tt>vertex_index</tt>
property.  For example, <tt>adjacency_list</tt> with <tt>VertexList=listS</tt>
does not have an internal <tt>vertex_index</tt> property.</td>
</tr>
</table>

<h3>Complexity</h3>

The time complexity is <i>O(V E<sup>2</sup>)</i> in the general case
or <i>O(V E U)</i> if capacity values are integers bounded by
some constant <i>U</i>.

<h3>Example</h3>

The program in <a
href="../example/edmonds-karp-eg.cpp"><tt>example/edmonds-karp-eg.cpp</tt></a>
reads an example maximum flow problem (a graph with edge capacities)
from a file in the DIMACS format and computes the maximum flow.


<h3>See Also</h3>

<a href="./push_relabel_max_flow.html"><tt>push_relabel_max_flow()</tt></a><br>
<a href="./boykov_kolmogorov_max_flow.html"><tt>boykov_kolmogorov_max_flow()</tt></a>.

<br>
<HR>
<TABLE>
<TR valign=top>
<TD nowrap>Copyright &copy; 2000-2001</TD><TD>
<A HREF="http://www.boost.org/users/people/jeremy_siek.html">Jeremy Siek</A>, Indiana University (<A HREF="mailto:jsiek@osl.iu.edu">jsiek@osl.iu.edu</A>)
</TD></TR></TABLE>

</BODY>
</HTML> 
<!--  LocalWords:  HTML Siek Edmonds BGCOLOR ffffff ee VLINK ALINK ff IMG SRC
 -->
<!--  LocalWords:  gif ALT BR sec edmonds karp TT DIV CELLPADDING TR TD PRE lt
 -->
<!--  LocalWords:  typename VertexListGraph CapacityEdgeMap ReverseEdgeMap gt
 -->
<!--  LocalWords:  ResidualCapacityEdgeMap VertexIndexMap src rev ColorMap pred
 -->
<!--  LocalWords:  PredEdgeMap tt href html hpp ul li nbsp br LvaluePropertyMap
 -->
<!--  LocalWords:  num ColorValue DIMACS cpp pre config iostream dimacs int std
 -->
<!--  LocalWords:  namespace vecS directedS cout endl iter ei HR valign nowrap
 -->
<!--  LocalWords:  jeremy siek htm Univ mailto jsiek lsc edu
p -->
