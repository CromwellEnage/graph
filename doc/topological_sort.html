<HTML>
<!--
     Copyright (c) Jeremy Siek 2000
    
     Distributed under the Boost Software License, Version 1.0.
     (See accompanying file LICENSE_1_0.txt or copy at
     http://www.boost.org/LICENSE_1_0.txt)
  -->
<Head>
<Title>Boost Graph Library: Topological Sort</Title>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
        ALINK="#ff0000"> 
<IMG SRC="../../../boost.png" 
     ALT="C++ Boost" width="277" height="86"> 

<BR Clear>


<H1><A NAME="sec:topological-sort">
<img src="figs/python.gif" alt="(Python)"/>
<TT>topological_sort</TT>
</H1>

<PRE>
BOOST_PARAMETER_BASIC_FUNCTION(
    (bool), topological_sort, ::boost::graph::keywords::tag,
    (required
        (graph, *(<i>unspecified predicate</i>))
    )
    (deduced
        (required
            (result, *(<i>unspecified predicate</i>))
        )
        (optional
            (vertex_index_map, *(<i>unspecified predicate</i>))
            (color_map, *(<i>unspecified predicate</i>))
        )
    )
)

template &lt;typename VertexListGraph, typename OutputIterator,
          typename P, typename T, typename R&gt;
void topological_sort(VertexListGraph&amp; g, OutputIterator result,
    const bgl_named_params&lt;P, T, R&gt;&amp; params = <i>all defaults</i>)
</PRE>

<P>
The topological sort algorithm creates a linear ordering of the
vertices such that if edge <i>(u,v)</i> appears in the graph, then
<i>v</i> comes before <i>u</i> in the ordering. The graph must be a
directed acyclic graph (DAG). The implementation consists mainly of a
call to <a
href="./depth_first_search.html"><tt>depth_first_search()</tt></a>.
</p>

<h3>Where Defined:</h3>
<a href="../../../boost/graph/topological_sort.hpp"><TT>boost/graph/topological_sort.hpp</TT></a>

<h3>Parameters</h3>

<table>
<tr valign="top">
<th>Category:</th>
<td>IN</td>
</tr>
<tr valign="top">
<th><a href="../../parameter/doc/html/index.html">Boost.Parameter</a>
keyword:</th>
<td bgcolor="#dfdfdf"><tt>boost::graph::keywords::_graph</tt></td>
</tr>
<tr valign="top">
<th>Passing options</th>
<td bgcolor="#dfdfff">By name or by position.</td>
</tr>
<tr valign="top">
<th>Old-style signature:</th>
<td>N/A</td>
</tr>
<tr valign="top">
<th>Description:</th>
<td>A directed acylic graph (DAG).  The graph type must be a model of <a
href="./VertexListGraph.html"><b>Vertex List Graph</b></a> and <a
href="./IncidenceGraph.html"><b>Incidence Graph</b></a>.  If the graph is not
a DAG then a <a href="./exception.html#not_a_dag"><tt>not_a_dag</tt></a>
exception will be thrown and the user should discard the contents of
<tt>result</tt> range.</td>
</tr>
<tr valign="top">
<th>Default:</th>
<td>N/A</td>
</tr>
<tr valign="top">
<th>Python:</th>
<td>The parameter is named <tt>graph</tt>.</td>
</tr>
<tr>
<td colspan="2"><hr /></td>
</tr>
<tr valign="top">
<th>Category:</th>
<td>OUT</td>
</tr>
<tr valign="top">
<th><a href="../../parameter/doc/html/index.html">Boost.Parameter</a>
keyword:</th>
<td bgcolor="#dfdfdf"><tt>boost::graph::keywords::_result</tt></td>
</tr>
<tr valign="top">
<th>Passing options</th>
<td bgcolor="#dfffdf">By position, by name, or if the preprocessor token
<tt>BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS</tt> is defined.</td>
</tr>
<tr valign="top">
<th>Old-style signature:</th>
<td>N/A</td>
</tr>
<tr valign="top">
<th>Description:</th>
<td>The vertex descriptors of the graph will be output to the <tt>result</tt>
output iterator in <b>reverse</b> topological order.  The iterator type must
model <a href="http://www.boost.com/sgi/stl/OutputIterator.html"><b>Output
Iterator</b></a>.</td>
</tr>
<tr valign="top">
<th>Default:</th>
<td>N/A</td>
</tr>
<tr valign="top">
<th>Python:</th>
<td>This parameter is not used in Python.  Instead, a Python <tt>list</tt>
containing the vertices in topological order is returned.</td>
</tr>
<tr>
<td colspan="2"><hr /></td>
</tr>
<tr valign="top">
<th>Category:</th>
<td>IN</td>
</tr>
<tr valign="top">
<th><a href="../../parameter/doc/html/index.html">Boost.Parameter</a>
keyword:</th>
<td bgcolor="#dfdfdf"><tt>boost::graph::keywords::_vertex_index_map</tt></td>
</tr>
<tr valign="top">
<th>Deducible?</th>
<td bgcolor="#dfffdf">Yes, if the preprocessor token
<tt>BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS</tt> is defined.</td>
</tr>
<tr valign="top">
<th>Old-style signature:</th>
<td bgcolor="#dfdfdf"><tt>vertex_index_map(VertexIndexMap i_map)</tt></td>
</tr>
<tr valign="top">
<th>Description:</th>
<td>This maps each vertex to an integer in the half-open range from zero to
the number of vertices in the graph argument.  This parameter is only
necessary when the default color property map is used.  The argument type must
be a model of <a href="../../property_map/doc/ReadablePropertyMap.html"><b
>Readable Property Map</b></a>.  The value type of the map must be an integer
type.  The vertex descriptor type of the graph needs to be usable as the key
type of the map.</td>
</tr>
<tr valign="top">
<th>Default:</th>
<td bgcolor="#dfdfdf"><tt>get(vertex_index, g)</tt><br />Note: if you use this
default, make sure your graph has an internal <tt>vertex_index</tt>
property.  For example, <tt>adjacency_list</tt> with <tt>VertexList=listS</tt>
does not have an internal <tt>vertex_index</tt> property.</td>
</tr>
<tr valign="top">
<th>Python:</th>
<td>Unsupported parameter.</td>
</tr>
<tr>
<td colspan="2"><hr /></td>
</tr>
<tr valign="top">
<th>Category:</th>
<td>UTIL/OUT</td>
</tr>
<tr valign="top">
<th><a href="../../parameter/doc/html/index.html">Boost.Parameter</a>
keyword:</th>
<td bgcolor="#dfdfdf"><tt>boost::graph::keywords::_color_map</tt></td>
</tr>
<tr valign="top">
<th>Deducible?</th>
<td bgcolor="#dfffdf">Yes, if the preprocessor token
<tt>BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS</tt> is defined.</td>
</tr>
<tr valign="top">
<th>Old-style signature:</th>
<td bgcolor="#dfdfdf"><tt>color_map(ColorMap color)</tt></td>
</tr>
<tr valign="top">
<th>Description:</th>
<td>This is used by the algorithm to keep track of its progress through the
graph.  The argument type must be a model of <a
href="../../property_map/doc/ReadWritePropertyMap.html"><b>Read/Write Property
Map</b></a> and its key type must be the graph's vertex descriptor type and
the value type of the color map must model <a href="./ColorValue.html"><b
>ColorValue</b></a>.</td>
</tr>
<tr valign="top">
<th>Default:</th>
<td bgcolor="#dfdfdf">A <a
href="../../property_map/doc/shared_array_property_map.html"><tt
>shared_array_property_map</tt></a> created from a shared array of
<tt>white_color</tt> values of size equal to the number of vertices in the
graph argument and using the index map argument for the index map.</td>
</tr>
<tr valign="top">
<th>Python:</th>
<td>The color map must be a <tt>vertex_color_map</tt> for the graph.</td>
</tr>
</table>

<H3>Complexity</H3>

The time complexity is <i>O(V + E)</i>.


<H3>Example</H3>

<P>
Calculate a topological ordering of the vertices.

<P>
<PRE>
  typedef adjacency_list&lt; vecS, vecS, directedS, color_property&lt;&gt; &gt; Graph;
  typedef boost::graph_traits&lt;Graph&gt;::vertex_descriptor Vertex;
  Pair edges[6] = { Pair(0,1), Pair(2,4),
                    Pair(2,5),
                    Pair(0,3), Pair(1,4),
                    Pair(4,3) };
  Graph G(6, edges, edges + 6);

  typedef std::vector&lt; Vertex &gt; container;
  container c;
  topological_sort(G, std::back_inserter(c));

  cout &lt;&lt; "A topological ordering: ";
  for ( container::reverse_iterator ii=c.rbegin(); ii!=c.rend(); ++ii)
    cout &lt;&lt; index(*ii) &lt;&lt; " ";
  cout &lt;&lt; endl;
</PRE>
The output is:
<PRE>
  A topological ordering: 2 5 0 1 4 3
</PRE>


<br>
<HR>
<TABLE>
<TR valign=top>
<TD nowrap>Copyright &copy; 2000-2001</TD><TD>
<A HREF="http://www.boost.org/people/jeremy_siek.htm">Jeremy Siek</A>, Indiana University (<A HREF="mailto:jsiek@osl.iu.edu">jsiek@osl.iu.edu</A>)
</TD></TR></TABLE>

</BODY>
</HTML> 
