<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--
    Copyright (c) 2004 Trustees of Indiana University

    Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
-->
<html>
<head>
<title>Boost Graph Library: betweenness_centrality_clustering</title>
<link rel="stylesheet" type="text/css" href="graph.css" />
</head>
<body>
<img src="../../../boost.png" alt="C++ Boost" width="277" height="86" /> 

<h1><img src="figs/python.gif"
alt="(Python)" /><tt>betweenness_centrality_clustering</tt></h1>

<h3>Synopsis</h3>

<p>If the configuration macro
<span class="cxx_code">BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS</span>
is defined, then the following function overload definition is available.</p>

<pre class="cxx_code">
<a href="../../parameter/doc/html/reference.html#boost-parameter-function-result-name-tag-namespace-arguments">BOOST_PARAMETER_FUNCTION</a>(
    (void), betweenness_centrality_clustering, ::boost::graph::keywords::tag,
    (required
        (graph, *)
    )
    (deduced
        (required
            (terminator_function
              , *(<span class="comment">/* unspecified predicate */</span>)
            )
        )
        (optional
            (edge_centrality_map
              , *(<span class="comment">/* unspecified predicate */</span>)
              , <span class="comment"
>// see parameter table for default value</span>
            )
            (vertex_index_map
              , *(<span class="comment">/* unspecified predicate */</span>)
              , <span class="comment"
>// see parameter table for default value</span>
            )
        )
    )
)
</pre>

<p>If the configuration macro
<span class="cxx_code">BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS</span>
is <strong>not</strong> defined, then the following function overload
definitions are available.</p>

<pre class="cxx_code">
template &lt;typename <a class="cxx_concept" href="MutableGraph.html"
>MutableGraph</a>, typename Done, typename EdgeCentralityMap, 
          typename VertexIndexMap&gt; 
void betweenness_centrality_clustering(
    MutableGraph&amp; graph, Done terminator_function,
    EdgeCentralityMap edge_centrality_map, VertexIndexMap vertex_index_map
);

template &lt;typename <a class="cxx_concept" href="MutableGraph.html"
>MutableGraph</a>, typename Done, typename EdgeCentralityMap&gt; 
void betweenness_centrality_clustering(
    MutableGraph&amp; graph, Done terminator_function,
    EdgeCentralityMap edge_centrality_map
);

template &lt;typename <a class="cxx_concept" href="MutableGraph.html"
>MutableGraph</a>, typename Done&gt; 
void betweenness_centrality_clustering(
    MutableGraph&amp; graph, Done terminator_function
);
</pre>

<h3><a name="sec:description"></a>Description</h3>

<p>This algorithm implements graph clustering based on edge betweenness
centrality.  It is an iterative algorithm, where in each step it computes the
edge betweenness centrality (via <a href="betweenness_centrality.html"
class="cxx_code">brandes_betweenness_centrality</a>) and removes the edge with
the maximum betweenness centrality.</p>

<h3><a name="sec:example"></a>Example</h3>

<p>The file <a href="../example/actor_clustering.cpp"
><tt>examples/actor_clustering.cpp</tt></a> contains an example of using
<span class="cxx_code">betweenness_centrality_clustering</span>.</p>

<h3><a name="sec:where_defined"></a>Where Defined</h3>

<p><a href="../../../boost/graph/bc_clustering.hpp"
><tt>boost/graph/bc_clustering.hpp</tt></a></p>

<h3><a name="sec:parameters"></a>Parameters</h3>

<p>If <strong>any</strong> of the following are true:</p>

<ul>
<li>This document renders the category of a parameter as black text on a white
background.</li>
<li>The configuration macro <span
class="cxx_code">BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS</span> is
<strong>not</strong> defined.</li>
</ul>

<p>Then the argument must be bound to this parameter by position.  On the
other hand, if <strong>all</strong> of the following are true:</p>

<ul>
<li>This document renders the category of a parameter as colored text on a
black background.</li>
<li>The configuration macro <span class="cxx_code"
>BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS</span> is defined.</li>
</ul>

<p>Then <a href="../../parameter/doc/html/index.html">Boost.Parameter's</a>
type deduction facilities can bind an unnamed argument to this parameter as
long as <strong>all</strong> of the following are true:</p>

<ul>
<li>The argument type fulfills the parameter type requirements.</li>
<li>The argument's position is the same as that of a parameter whose category
is rendered by this document such that the text is of the same color.</li>
</ul>

<table class="parameters">
<tr>
<th>Category:</th>
<td>IN</td>
</tr>
<tr>
<th><a href="../../parameter/doc/html/index.html">Boost.Parameter</a>
keyword:</th>
<td class="cxx_code">boost::graph::keywords::_graph</td>
</tr>
<tr>
<th>Unnamed version:</th>
<td class="cxx_code">const Graph&amp; graph</td>
</tr>
<tr>
<th>Description:</th>
<td>The graph object on which the algorithm will be applied.  Its type must be
a model of <a class="cxx_concept" href="VertexListGraph.html">Vertex List
Graph</a> and <a class="cxx_concept" href="IncidenceGraph.html">Incidence
Graph</a>.  When the default edge centrality map is used, the graph type must
also model <a class="cxx_concept" href="EdgeListGraph.html">Edge List
Graph</a> and <a class="cxx_concept" href="MutableGraph.html">Mutable
Graph</a>.</td>
</tr>
<tr>
<th>Python:</th>
<td>The parameter is named <span class="python_code">graph</span>.</td>
</tr>
<tr>
<td colspan="2"><hr /></td>
</tr>
<tr class="deduced_param_0">
<th>Category:</th>
<td>IN</td>
</tr>
<tr>
<th><a href="../../parameter/doc/html/index.html">Boost.Parameter</a>
keyword:</th>
<td class="cxx_code">boost::graph::keywords::_terminator_function</td>
</tr>
<tr>
<th>Unnamed version:</th>
<td class="cxx_code">Done terminator_function</td>
</tr>
<tr>
<th>Description:</th>
<td>The function object that determines when the algorithm terminates.  (The
edge found when the algorithm terminates will not be removed.)  It must be a
ternary function object thats accepts the maximum centrality, the descriptor
of the edge that will be removed, and the graph argument.  Furthermore, it
must have a nested <span class="cxx_code">centrality_type</span> type
definition.</td>
</tr>
<tr>
<th>Python:</th>
<td>Unsupported parameter.</td>
</tr>
<tr>
<td colspan="2"><hr /></td>
</tr>
<tr class="deduced_param_0">
<th>Category:</th>
<td>OUT/UTIL</td>
</tr>
<tr>
<th><a href="../../parameter/doc/html/index.html">Boost.Parameter</a>
keyword:</th>
<td class="cxx_code">boost::graph::keywords::_edge_centrality_map</td>
</tr>
<tr>
<th>Unnamed version:</th>
<td class="cxx_code">EdgeCentralityMap edge_centrality_map</td>
</tr>
<tr>
<th>Description:</th>
<td>This property map is used to accumulate the betweenness centrality of each
edge, and is a secondary form of output for the algorithm.  The argument type
must be a model of <a href="../../property_map/doc/ReadWritePropertyMap.html"
class="cxx_concept">Read/Write Property Map</a>, with the graph's edge
descriptor type as its key type.  The value type of this property map should
be the same as the value type of the centrality map argument.</td>
</tr>
<tr>
<th>Default:</th>
<td>A <a href="../../property_map/doc/shared_array_property_map.html"
class="cxx_code">shared_array_property_map</a> of default-constructed <span
class="cxx_code">centrality_type</span> objects (where <span class="cxx_code"
>centrality_type</span> is that of the terminator function argument), and of
size <span class="cxx_code">num_edges(graph)</span>, and using the graph's
internal edge index map.</td>
</tr>
<tr>
<th>Python:</th>
<td>This map must be an <span class="python_code">edge_double_map</span> for
the graph.</td>
</tr>
<tr>
<th>Python default:</th>
<td class="python_code">graph.get_edge_double_map("centrality")</td>
</tr>
<tr>
<td colspan="2"><hr /></td>
</tr>
<tr class="deduced_param_0">
<th>Category:</th>
<td>IN</td>
</tr>
<tr>
<th><a href="../../parameter/doc/html/index.html">Boost.Parameter</a>
keyword:</th>
<td class="cxx_code">boost::graph::keywords::_vertex_index_map</td>
</tr>
<tr>
<th>Unnamed version:</th>
<td class="cxx_code">VertexIndexMap vertex_index_map</td>
</tr>
<tr>
<th>Description:</th>
<td>This maps each vertex to an integer in the range <tt>[0, <span
class="cxx_code">num_vertices(graph)</span>)</tt>.  This is necessary for
efficient updates of the heap data structure when an edge is relaxed.  The
argument type must be a model of <a class="cxx_concept"
href="../../property_map/doc/ReadablePropertyMap.html">Readable Property
Map</a>.  The value type of the map must be an integer type.  The vertex
descriptor type of the graph needs to be usable as the key type of the
map.</td>
</tr>
<tr>
<th>Default:</th>
<td><span class="cxx_code">get(vertex_index, graph)</span> if the graph has an
internal <span class="cxx_code">vertex_index</span> property, otherwise
<span class="cxx_code">dummy_property_map()</span></td>
</tr>
<tr>
<th>Note:</th>
<td>If you use this default, make sure your graph has an internal
<span class="cxx_code">vertex_index</span> property.  For example,
<span class="cxx_code">adjacency_list</span> with <span class="cxx_code"
>VertexList=listS</span> does not have an internal <span class="cxx_code"
>vertex_index</span> property, so the default value of this argument will be a
<span class="cxx_code">dummy_property_map</span> object.</td>
</tr>
<tr>
<th>Python:</th>
<td>Unsupported parameter.</td>
</tr>
</table>

<br />
<hr />
<table>
<tr>
<td class="copyright">Copyright &copy; 2004</td>
<td><a href="http://www.boost.org/people/doug_gregor.htm">Douglas Gregor</a>,
Indiana University (<a class="external"
href="mailto:dgregor@cs.indiana.edu">dgregor@cs.indiana.edu</a>)</td>
</tr>
<tr>
<td></td>
<td><a class="external" href="https://homes.cs.washington.edu/~al75">Andrew
Lumsdaine</a>, Indiana University
(<a class="external" href="mailto:lums@osl.iu.edu">lums@osl.iu.edu</a>)</td>
</tr>
</table>

</body>
</html>
