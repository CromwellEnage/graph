// Copyright (c) Jeremy Siek 2001
// Copyright (c) Douglas Gregor 2004
//
// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

// NOTE: this final is generated by libs/graph/doc/biconnected_components.w

#ifndef BOOST_GRAPH_BICONNECTED_COMPONENTS_HPP
#define BOOST_GRAPH_BICONNECTED_COMPONENTS_HPP

#include <stack>
#include <vector>
#include <algorithm> // for std::min and std::max
#include <boost/config.hpp>
#include <boost/limits.hpp>
#include <boost/graph/graph_traits.hpp>
#include <boost/graph/graph_concepts.hpp>
#include <boost/property_map/property_map.hpp>
#include <boost/graph/depth_first_search.hpp>
#include <boost/graph/graph_utility.hpp>
#include <boost/core/enable_if.hpp>
#include <boost/type_traits/remove_const.hpp>
#include <boost/concept/assert.hpp>
#include <boost/assert.hpp>

#if defined(BOOST_GRAPH_CONFIG_CAN_NAME_ARGUMENTS) && \
    !(defined(__MINGW32__) && BOOST_WORKAROUND(BOOST_GCC, < 60000))
#include <boost/parameter/preprocessor.hpp>
#include <boost/mpl/bool.hpp>
#include <boost/mpl/eval_if.hpp>
#include <boost/mpl/has_key.hpp>
#include <boost/type_traits/remove_reference.hpp>
#else
#include <boost/parameter/are_tagged_arguments.hpp>
#include <boost/parameter/is_argument_pack.hpp>
#include <boost/parameter/value_type.hpp>
#endif

namespace boost { namespace detail {

    template<typename ComponentMap, typename DiscoverTimeMap,
             typename LowPointMap, typename PredecessorMap,
             typename OutputIterator, typename Stack,
             typename ArticulationVector, typename IndexMap,
             typename DFSVisitor>
    class biconnected_components_visitor : public boost::graph::dfs_visitor<>
    {
        ComponentMap comp;
        std::size_t& c;
        std::size_t& children_of_root;
        DiscoverTimeMap dtm;
        std::size_t& dfs_time;
        LowPointMap lowpt;
        PredecessorMap pred;
        OutputIterator out;
        Stack& S;
        ArticulationVector& is_articulation_point;
        IndexMap index_map;
        DFSVisitor vis;

    public:
        biconnected_components_visitor(
            ComponentMap comp, std::size_t& c, std::size_t& children_of_root,
            DiscoverTimeMap dtm, std::size_t& dfs_time, LowPointMap lowpt,
            PredecessorMap pred, OutputIterator out, Stack& S,
            ArticulationVector& is_articulation_point, IndexMap index_map,
            DFSVisitor vis
        ) : boost::graph::dfs_visitor<>(), comp(comp), c(c),
            children_of_root(children_of_root), dtm(dtm), dfs_time(dfs_time),
            lowpt(lowpt), pred(pred), out(out), S(S),
            is_articulation_point(is_articulation_point),
            index_map(index_map), vis(vis)
        {
        }

        template <typename Vertex, typename Graph>
        inline void initialize_vertex(const Vertex& u, Graph& g)
        {
            put(this->pred, u, u);
            this->vis.initialize_vertex(u, g);
        }

        template <typename Vertex, typename Graph>
        inline void start_vertex(const Vertex& u, Graph& g)
        {
            this->children_of_root = 0;
            this->vis.start_vertex(u, g);
        }

        template <typename Vertex, typename Graph>
        inline void discover_vertex(const Vertex& u, Graph& g)
        {
            put(this->dtm, u, ++this->dfs_time);
            put(this->lowpt, u, get(this->dtm, u));
            this->vis.discover_vertex(u, g);
        }

        template <typename Edge, typename Graph>
        inline void examine_edge(const Edge& e, Graph& g)
        {
            this->vis.examine_edge(e, g);
        }

        template <typename Edge, typename Graph>
        void tree_edge(const Edge& e, Graph& g)
        {
            typename boost::graph_traits<
                Graph
            >::vertex_descriptor src = source(e, g);
            typename boost::graph_traits<
                Graph
            >::vertex_descriptor tgt = target(e, g);

            this->S.push(e);
            put(this->pred, tgt, src);

            if (get(this->pred, src) == src)
            {
                ++this->children_of_root;
            }

            this->vis.tree_edge(e, g);
        }

        template <typename Edge, typename Graph>
        void back_edge(const Edge& e, Graph& g)
        {
            BOOST_USING_STD_MIN();

            typename boost::graph_traits<
                Graph
            >::vertex_descriptor src = source(e, g);
            typename boost::graph_traits<
                Graph
            >::vertex_descriptor tgt = target(e, g);

            if (tgt != get(this->pred, src))
            {
                this->S.push(e);
                put(
                    this->lowpt,
                    src,
                    min BOOST_PREVENT_MACRO_SUBSTITUTION(
                        get(this->lowpt, src),
                        get(this->dtm, tgt)
                    )
                );
            }

            this->vis.back_edge(e, g);
        }

        template <typename Edge, typename Graph>
        inline void forward_or_cross_edge(const Edge& e, Graph& g)
        {
            this->vis.forward_or_cross_edge(e, g);
        }

        template <typename Vertex, typename Graph>
        void finish_vertex(const Vertex& u, Graph& g)
        {
            BOOST_USING_STD_MIN();
            Vertex parent = get(this->pred, u);

            if (parent == u)
            {
                // Root of tree is special
                this->is_articulation_point[
                    get(this->index_map, u)
                ] = (this->children_of_root > 1);
            }
            else
            {
                put(
                    this->lowpt,
                    parent,
                    min BOOST_PREVENT_MACRO_SUBSTITUTION(
                        get(this->lowpt, parent),
                        get(this->lowpt, u)
                    )
                );

                if (get(this->lowpt, u) >= get(this->dtm, parent))
                {
                    this->is_articulation_point[
                        get(this->index_map, parent)
                    ] = true;

                    while (
                        get(
                            this->dtm,
                            source(this->S.top(), g)
                        ) >= get(this->dtm, u)
                    )
                    {
                        put(this->comp, this->S.top(), this->c);
                        this->S.pop();
                    }

                    BOOST_ASSERT(source(this->S.top(), g) == parent);
                    BOOST_ASSERT(target(this->S.top(), g) == u);
                    put(this->comp, this->S.top(), this->c);
                    this->S.pop();
                    ++this->c;
                }
            }

            if (this->is_articulation_point[get(this->index_map, u)])
            {
                *this->out++ = u;
            }

            this->vis.finish_vertex(u, g);
        }
    };

    template<typename Graph, typename ComponentMap, typename OutputIterator,
        typename VertexIndexMap, typename DiscoverTimeMap, typename LowPointMap,
        typename PredecessorMap, typename DFSVisitor>
    std::pair<std::size_t, OutputIterator>
      biconnected_components_impl(const Graph & g, ComponentMap comp,
          OutputIterator out, VertexIndexMap index_map, DiscoverTimeMap dtm,
          LowPointMap lowpt, PredecessorMap pred, DFSVisitor dfs_vis)
    {
      typedef typename graph_traits<Graph>::vertex_descriptor vertex_t;
      typedef typename graph_traits<Graph>::edge_descriptor edge_t;
      BOOST_CONCEPT_ASSERT(( VertexListGraphConcept<Graph> ));
      BOOST_CONCEPT_ASSERT(( IncidenceGraphConcept<Graph> ));
      BOOST_CONCEPT_ASSERT(( WritablePropertyMapConcept<ComponentMap, edge_t> ));
      BOOST_CONCEPT_ASSERT(( ReadWritePropertyMapConcept<DiscoverTimeMap,
                                                  vertex_t> ));
      BOOST_CONCEPT_ASSERT(( ReadWritePropertyMapConcept<LowPointMap, vertex_t > ));
      BOOST_CONCEPT_ASSERT(( ReadWritePropertyMapConcept<PredecessorMap,
                                                  vertex_t> ));

      std::size_t num_components = 0;
      std::size_t children_of_root;
      std::size_t dfs_time = 0;
      std::stack<edge_t> S;
      std::vector<char> is_articulation_point(num_vertices(g));

      biconnected_components_visitor<ComponentMap, DiscoverTimeMap,
        LowPointMap, PredecessorMap, OutputIterator, std::stack<edge_t>, 
        std::vector<char>, VertexIndexMap, DFSVisitor>
      vis(comp, num_components, children_of_root, dtm, dfs_time,
          lowpt, pred, out, S, is_articulation_point, index_map, dfs_vis);

#if defined(BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS)
      depth_first_search(g, vis, index_map);
#else
      depth_first_search(
        g,
        boost::graph::keywords::_visitor = vis,
        boost::graph::keywords::_vertex_index_map = index_map
      );
#endif

      return std::pair<std::size_t, OutputIterator>(num_components, vis.out);
    }

#if !defined(BOOST_GRAPH_CONFIG_CAN_NAME_ARGUMENTS) || \
    (defined(__MINGW32__) && BOOST_WORKAROUND(BOOST_GCC, < 60000))
    template <typename PredecessorMap>
    struct bicomp_dispatch3
    {
  template<typename Graph, typename ComponentMap, typename OutputIterator,
                typename VertexIndexMap, typename DiscoverTimeMap, 
                typename LowPointMap, class P, class T, class R>
      static std::pair<std::size_t, OutputIterator> apply (const Graph & g, 
          ComponentMap comp, OutputIterator out, VertexIndexMap index_map, 
          DiscoverTimeMap dtm, LowPointMap lowpt, 
          const bgl_named_params<P, T, R>& params, PredecessorMap pred)
      {
        return biconnected_components_impl
                (g, comp, out, index_map, dtm, lowpt, pred,
                 choose_param(get_param(params, graph_visitor),
                    make_dfs_visitor(null_visitor())));
      }
    };
    
    template <>
    struct bicomp_dispatch3<param_not_found>
    {
      template<typename Graph, typename ComponentMap, typename OutputIterator,
                typename VertexIndexMap, typename DiscoverTimeMap, 
                typename LowPointMap, class P, class T, class R>
      static std::pair<std::size_t, OutputIterator> apply (const Graph & g, 
          ComponentMap comp, OutputIterator out, VertexIndexMap index_map, 
          DiscoverTimeMap dtm, LowPointMap lowpt, 
          const bgl_named_params<P, T, R>& params, 
          param_not_found)
  {
    typedef typename graph_traits<Graph>::vertex_descriptor vertex_t;
    std::vector<vertex_t> pred(num_vertices(g));
    vertex_t vert = graph_traits<Graph>::null_vertex();

        return biconnected_components_impl
                (g, comp, out, index_map, dtm, lowpt, 
              make_iterator_property_map(pred.begin(), index_map, vert),
                 choose_param(get_param(params, graph_visitor),
                    make_dfs_visitor(null_visitor())));
  }
    };

    template <typename LowPointMap>
    struct bicomp_dispatch2
    {
  template<typename Graph, typename ComponentMap, typename OutputIterator,
                typename VertexIndexMap, typename DiscoverTimeMap, 
                typename P, typename T, typename R>
      static std::pair<std::size_t, OutputIterator> apply (const Graph& g, 
          ComponentMap comp, OutputIterator out, VertexIndexMap index_map, 
          DiscoverTimeMap dtm, const bgl_named_params<P, T, R>& params, 
          LowPointMap lowpt)
      {
        typedef typename get_param_type< vertex_predecessor_t, bgl_named_params<P,T,R> >::type dispatch_type;

        return bicomp_dispatch3<dispatch_type>::apply
            (g, comp, out, index_map, dtm, lowpt, params, 
             get_param(params, vertex_predecessor));
      }
    };


    template <>
    struct bicomp_dispatch2<param_not_found>
    {
      template<typename Graph, typename ComponentMap, typename OutputIterator,
                typename VertexIndexMap, typename DiscoverTimeMap, 
                typename P, typename T, typename R>
      static std::pair<std::size_t, OutputIterator> apply (const Graph& g, 
          ComponentMap comp, OutputIterator out, VertexIndexMap index_map, 
          DiscoverTimeMap dtm, const bgl_named_params<P, T, R>& params, 
          param_not_found)
  {
    typedef typename graph_traits<Graph>::vertices_size_type
      vertices_size_type;
    std::vector<vertices_size_type> lowpt(num_vertices(g));
        vertices_size_type vst(0);

        typedef typename get_param_type< vertex_predecessor_t, bgl_named_params<P,T,R> >::type dispatch_type;
  
        return bicomp_dispatch3<dispatch_type>::apply
            (g, comp, out, index_map, dtm,
             make_iterator_property_map(lowpt.begin(), index_map, vst),
             params, get_param(params, vertex_predecessor));
      }
    };

    template <typename DiscoverTimeMap>
    struct bicomp_dispatch1
    {
      template<typename Graph, typename ComponentMap, typename OutputIterator,
                typename VertexIndexMap, class P, class T, class R>
      static std::pair<std::size_t, OutputIterator> apply(const Graph& g, 
          ComponentMap comp, OutputIterator out, VertexIndexMap index_map, 
          const bgl_named_params<P, T, R>& params, DiscoverTimeMap dtm)
      {
        typedef typename get_param_type< vertex_lowpoint_t, bgl_named_params<P,T,R> >::type dispatch_type;

        return bicomp_dispatch2<dispatch_type>::apply
            (g, comp, out, index_map, dtm, params, 
             get_param(params, vertex_lowpoint));
      }
    };

    template <>
    struct bicomp_dispatch1<param_not_found>
    {
      template<typename Graph, typename ComponentMap, typename OutputIterator,
                typename VertexIndexMap, class P, class T, class R>
      static std::pair<std::size_t, OutputIterator> apply(const Graph& g, 
          ComponentMap comp, OutputIterator out, VertexIndexMap index_map, 
          const bgl_named_params<P, T, R>& params, param_not_found)
      {
        typedef typename graph_traits<Graph>::vertices_size_type
            vertices_size_type;
        std::vector<vertices_size_type> discover_time(num_vertices(g));
    vertices_size_type vst(0);

        typedef typename get_param_type< vertex_lowpoint_t, bgl_named_params<P,T,R> >::type dispatch_type;

        return bicomp_dispatch2<dispatch_type>::apply
            (g, comp, out, index_map, 
              make_iterator_property_map(discover_time.begin(), index_map, vst),
             params, get_param(params, vertex_lowpoint));
      }
    };
#endif  // !defined(BOOST_GRAPH_CONFIG_CAN_NAME_ARGUMENTS)
}} // end namespace boost::detail

#if defined(BOOST_GRAPH_CONFIG_CAN_NAME_ARGUMENTS) && \
    !(defined(__MINGW32__) && BOOST_WORKAROUND(BOOST_GCC, < 60000))

namespace boost { namespace graph {

#if defined(BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS)
  BOOST_PARAMETER_FUNCTION(
    (
      boost::lazy_enable_if<
        typename mpl::eval_if<
          boost::detail::has_internal_vertex_property_map<
            typename boost::detail::mutable_value_type<
              Args,
              boost::graph::keywords::tag::graph
            >::type,
            vertex_index_t
          >,
          mpl::has_key<Args,boost::graph::keywords::tag::result>,
          mpl::false_
        >::type,
        boost::detail::make_size_t_value_pair<
          Args,
          boost::graph::keywords::tag::result
        >
      >
    ), biconnected_components, ::boost::graph::keywords::tag,
    (required
      (graph, *(boost::detail::argument_predicate<is_vertex_list_graph>))
    )
    (deduced
      (required
        (component_map
          ,*(
            boost::detail::argument_with_graph_predicate<
              boost::detail::is_edge_property_map_of_graph
            >
          )
        )
        (result
          ,*(boost::detail::argument_predicate<boost::detail::is_iterator>)
        )
      )
    )
    (optional
      (discover_time_map
        ,*(
          boost::detail::argument_with_graph_predicate<
            boost::detail::is_vertex_to_integer_map_of_graph
          >
        )
        ,make_shared_array_property_map(
          num_vertices(graph),
          num_vertices(graph) - num_vertices(graph),
          get(vertex_index, graph)
        )
      )
      (lowpoint_map
        ,*(
          boost::detail::argument_with_graph_predicate<
            boost::detail::is_vertex_to_integer_map_of_graph
          >
        )
        ,make_shared_array_property_map(
          num_vertices(graph),
          num_vertices(graph) - num_vertices(graph),
          get(vertex_index, graph)
        )
      )
      (predecessor_map
        ,*(
          boost::detail::argument_with_graph_predicate<
            boost::detail::is_vertex_to_vertex_map_of_graph
          >
        )
        ,make_shared_array_property_map(
          num_vertices(graph),
          boost::detail::get_null_vertex(graph),
          get(vertex_index, graph)
        )
      )
      (visitor
        ,*(
          boost::detail::argument_with_graph_predicate<
            boost::detail::is_dfs_visitor
          >
        )
        ,default_dfs_visitor()
      )
    )
  )
#else   // !defined(BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS)
  BOOST_PARAMETER_FUNCTION(
    (
      boost::lazy_enable_if<
        typename mpl::eval_if<
          typename mpl::eval_if<
            typename mpl::eval_if<
              boost::detail::is_bgl_named_param_argument<
                Args,
                boost::graph::keywords::tag::result
              >,
              mpl::true_,
              boost::detail::is_bgl_named_param_argument<
                Args,
                boost::graph::keywords::tag::discover_time_map
              >
            >::type,
            mpl::false_,
            boost::detail::has_internal_vertex_property_map<
              typename boost::detail::mutable_value_type<
                Args,
                boost::graph::keywords::tag::graph
              >::type,
              vertex_index_t
            >
          >::type,
          mpl::eval_if<
            boost::detail::is_vertex_property_map_of_graph_argument<
              Args,
              boost::graph::keywords::tag::result,
              boost::graph::keywords::tag::graph
            >,
            mpl::false_,
            mpl::has_key<Args,boost::graph::keywords::tag::result>
          >,
          mpl::false_
        >::type,
        boost::detail::make_size_t_value_pair<
          Args,
          boost::graph::keywords::tag::result
        >
      >
    ), biconnected_components, ::boost::graph::keywords::tag,
    (required
      (graph, *)
      (component_map, *)
      (result, *)
    )
    (optional
      (discover_time_map
        ,*
        ,make_shared_array_property_map(
          num_vertices(graph),
          num_vertices(graph) - num_vertices(graph),
          get(vertex_index, graph)
        )
      )
      (lowpoint_map
        ,*
        ,make_shared_array_property_map(
          num_vertices(graph),
          num_vertices(graph) - num_vertices(graph),
          get(vertex_index, graph)
        )
      )
      (predecessor_map
        ,*
        ,make_shared_array_property_map(
          num_vertices(graph),
          boost::detail::get_null_vertex(graph),
          get(vertex_index, graph)
        )
      )
      (visitor
        ,*
        ,default_dfs_visitor()
      )
    )
  )
#endif  // BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS
  {
    return boost::detail::biconnected_components_impl(
      graph,
      component_map,
      result,
      get(vertex_index, graph),
      discover_time_map,
      lowpoint_map,
      predecessor_map,
      visitor
    );
  }

#if defined(BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS)
  BOOST_PARAMETER_FUNCTION(
    (
      boost::lazy_enable_if<
        typename mpl::eval_if<
          boost::detail::has_internal_vertex_property_map<
            typename boost::detail::mutable_value_type<
              Args,
              boost::graph::keywords::tag::graph
            >::type,
            vertex_index_t
          >,
          mpl::false_,
          mpl::has_key<Args,boost::graph::keywords::tag::result>
        >::type,
        boost::detail::make_size_t_value_pair<
          Args,
          boost::graph::keywords::tag::result
        >
      >
    ), biconnected_components, ::boost::graph::keywords::tag,
    (required
      (graph, *(boost::detail::argument_predicate<is_vertex_list_graph>))
    )
    (deduced
      (required
        (result
          ,*(boost::detail::argument_predicate<boost::detail::is_iterator>)
        )
        (component_map
          ,*(
            boost::detail::argument_with_graph_predicate<
              boost::detail::is_edge_property_map_of_graph
            >
          )
        )
        (vertex_index_map
          ,*(
            boost::detail::argument_with_graph_predicate<
              boost::detail::is_vertex_to_integer_map_of_graph
            >
          )
        )
      )
      (optional
        (visitor
          ,*(
            boost::detail::argument_with_graph_predicate<
              boost::detail::is_dfs_visitor
            >
          )
          ,default_dfs_visitor()
        )
      )
    )
  )
#else   // !defined(BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS)
  BOOST_PARAMETER_FUNCTION(
    (
      boost::lazy_enable_if<
        typename mpl::eval_if<
          typename mpl::eval_if<
            typename mpl::eval_if<
              boost::detail::is_bgl_named_param_argument<
                Args,
                boost::graph::keywords::tag::result
              >,
              mpl::true_,
              boost::detail::is_bgl_named_param_argument<
                Args,
                boost::graph::keywords::tag::vertex_index_map
              >
            >::type,
            mpl::true_,
            boost::detail::has_internal_vertex_property_map<
              typename boost::detail::mutable_value_type<
                Args,
                boost::graph::keywords::tag::graph
              >::type,
              vertex_index_t
            >
          >::type,
          mpl::false_,
          mpl::eval_if<
            boost::detail::is_vertex_property_map_of_graph_argument<
              Args,
              boost::graph::keywords::tag::result,
              boost::graph::keywords::tag::graph
            >,
            mpl::false_,
            mpl::has_key<Args,boost::graph::keywords::tag::result>
          >
        >::type,
        boost::detail::make_size_t_value_pair<
          Args,
          boost::graph::keywords::tag::result
        >
      >
    ), biconnected_components, ::boost::graph::keywords::tag,
    (required
      (graph, *)
      (component_map, *)
      (result, *)
      (vertex_index_map, *)
    )
    (optional
      (visitor, *, default_dfs_visitor())
    )
  )
#endif  // BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS
  {
    return boost::detail::biconnected_components_impl(
      graph,
      component_map,
      result,
      vertex_index_map,
      make_shared_array_property_map(
        num_vertices(graph),
        num_vertices(graph) - num_vertices(graph),
        vertex_index_map
      ),
      make_shared_array_property_map(
        num_vertices(graph),
        num_vertices(graph) - num_vertices(graph),
        vertex_index_map
      ),
      make_shared_array_property_map(
        num_vertices(graph),
        boost::detail::get_null_vertex(graph),
        vertex_index_map
      ),
      visitor
    );
  }
}} // end namespace boost::graph

#endif  // BOOST_GRAPH_CONFIG_CAN_NAME_ARGUMENTS

#include <boost/graph/detail/dummy_output_iterator.hpp>

#if defined(BOOST_GRAPH_CONFIG_CAN_NAME_ARGUMENTS) && \
    !(defined(__MINGW32__) && BOOST_WORKAROUND(BOOST_GCC, < 60000))

namespace boost { namespace graph {

#if defined(BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS)
  BOOST_PARAMETER_FUNCTION(
    (
      boost::disable_if<
        typename mpl::eval_if<
          boost::detail::has_internal_vertex_property_map<
            typename boost::detail::mutable_value_type<
              Args,
              boost::graph::keywords::tag::graph
            >::type,
            vertex_index_t
          >,
          mpl::has_key<Args,boost::graph::keywords::tag::result>,
          mpl::true_
        >::type,
        std::size_t
      >
    ), biconnected_components, ::boost::graph::keywords::tag,
    (required
      (graph, *(boost::detail::argument_predicate<is_vertex_list_graph>))
    )
    (deduced
      (required
        (component_map
          ,*(
            boost::detail::argument_with_graph_predicate<
              boost::detail::is_edge_property_map_of_graph
            >
          )
        )
      )
      (optional
        (discover_time_map
          ,*(
            boost::detail::argument_with_graph_predicate<
              boost::detail::is_vertex_to_integer_map_of_graph
            >
          )
          ,make_shared_array_property_map(
            num_vertices(graph),
            num_vertices(graph) - num_vertices(graph),
            get(vertex_index, graph)
          )
        )
        (predecessor_map
          ,*(
            boost::detail::argument_with_graph_predicate<
              boost::detail::is_vertex_to_vertex_map_of_graph
            >
          )
          ,make_shared_array_property_map(
            num_vertices(graph),
            boost::detail::get_null_vertex(graph),
            get(vertex_index, graph)
          )
        )
        (visitor
          ,*(
            boost::detail::argument_with_graph_predicate<
              boost::detail::is_dfs_visitor
            >
          )
          ,default_dfs_visitor()
        )
      )
    )
    (optional
      (lowpoint_map
        ,*(
          boost::detail::argument_with_graph_predicate<
            boost::detail::is_vertex_to_integer_map_of_graph
          >
        )
        ,make_shared_array_property_map(
          num_vertices(graph),
          num_vertices(graph) - num_vertices(graph),
          get(vertex_index, graph)
        )
      )
    )
  )
#else   // !defined(BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS)
  BOOST_PARAMETER_FUNCTION(
    (
      boost::disable_if<
        typename mpl::eval_if<
          typename mpl::eval_if<
            typename mpl::eval_if<
              typename mpl::has_key<
                Args,
                boost::graph::keywords::tag::discover_time_map
              >::type,
              mpl::eval_if<
                boost::detail::is_bgl_named_param_argument<
                  Args,
                  boost::graph::keywords::tag::discover_time_map
                >,
                mpl::true_,
                mpl::eval_if<
                  boost::detail::is_bgl_named_param_argument<
                    Args,
                    boost::graph::keywords::tag::predecessor_map
                  >,
                  mpl::true_,
                  mpl::eval_if<
                    boost::detail::is_vertex_property_map_of_graph_argument<
                      Args,
                      boost::graph::keywords::tag::discover_time_map,
                      boost::graph::keywords::tag::graph
                    >,
                    mpl::false_,
                    mpl::true_
                  >
                >
              >,
              mpl::false_
            >::type,
            mpl::false_,
            boost::detail::has_internal_vertex_property_map<
              typename boost::detail::mutable_value_type<
                Args,
                boost::graph::keywords::tag::graph
              >::type,
              vertex_index_t
            >
          >::type,
          mpl::has_key<Args,boost::graph::keywords::tag::result>,
          mpl::true_
        >::type,
        std::size_t
      >
    ), biconnected_components, ::boost::graph::keywords::tag,
    (required
      (graph, *)
      (component_map, *)
    )
    (optional
      (discover_time_map
        ,*
        ,make_shared_array_property_map(
          num_vertices(graph),
          num_vertices(graph) - num_vertices(graph),
          get(vertex_index, graph)
        )
      )
      (predecessor_map
        ,*
        ,make_shared_array_property_map(
          num_vertices(graph),
          boost::detail::get_null_vertex(graph),
          get(vertex_index, graph)
        )
      )
      (visitor, *, default_dfs_visitor())
      (lowpoint_map
        ,*
        ,make_shared_array_property_map(
          num_vertices(graph),
          num_vertices(graph) - num_vertices(graph),
          get(vertex_index, graph)
        )
      )
    )
  )
#endif  // BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS
  {
    return boost::detail::biconnected_components_impl(
      graph,
      component_map,
      boost::graph_detail::dummy_output_iterator(),
      get(vertex_index, graph),
      discover_time_map,
      lowpoint_map,
      predecessor_map,
      visitor
    ).first;
  }

#if defined(BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS)
  BOOST_PARAMETER_FUNCTION(
    (
      boost::disable_if<
        typename mpl::eval_if<
          boost::detail::has_internal_vertex_property_map<
            typename boost::detail::mutable_value_type<
              Args,
              boost::graph::keywords::tag::graph
            >::type,
            vertex_index_t
          >,
          mpl::true_,
          mpl::has_key<Args,boost::graph::keywords::tag::result>
        >::type,
        std::size_t
      >
    ), biconnected_components, ::boost::graph::keywords::tag,
    (required
      (graph, *(boost::detail::argument_predicate<is_vertex_list_graph>))
    )
    (deduced
      (required
        (component_map
          ,*(
            boost::detail::argument_with_graph_predicate<
              boost::detail::is_edge_property_map_of_graph
            >
          )
        )
        (vertex_index_map
          ,*(
            boost::detail::argument_with_graph_predicate<
              boost::detail::is_vertex_to_integer_map_of_graph
            >
          )
        )
      )
      (optional
        (visitor
          ,*(
            boost::detail::argument_with_graph_predicate<
              boost::detail::is_dfs_visitor
            >
          )
          ,default_dfs_visitor()
        )
      )
    )
  )
#else   // !defined(BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS)
  BOOST_PARAMETER_FUNCTION(
    (
      boost::disable_if<
        typename mpl::eval_if<
          typename mpl::eval_if<
            typename mpl::eval_if<
              boost::detail::is_bgl_named_param_argument<
                Args,
                boost::graph::keywords::tag::vertex_index_map
              >,
              mpl::true_,
              boost::detail::is_bgl_named_param_argument<
                Args,
                boost::graph::keywords::tag::visitor
              >
            >::type,
            mpl::true_,
            boost::detail::has_internal_vertex_property_map<
              typename boost::detail::mutable_value_type<
                Args,
                boost::graph::keywords::tag::graph
              >::type,
              vertex_index_t
            >
          >::type,
          mpl::true_,
          mpl::has_key<Args,boost::graph::keywords::tag::result>
        >::type,
        std::size_t
      >
    ), biconnected_components, ::boost::graph::keywords::tag,
    (required
      (graph, *)
      (component_map, *)
      (vertex_index_map, *)
    )
    (optional
      (visitor, *, default_dfs_visitor())
    )
  )
#endif  // BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS
  {
    return boost::detail::biconnected_components_impl(
      graph,
      component_map,
      boost::graph_detail::dummy_output_iterator(),
      vertex_index_map,
      make_shared_array_property_map(
        num_vertices(graph),
        num_vertices(graph) - num_vertices(graph),
        vertex_index_map
      ),
      make_shared_array_property_map(
        num_vertices(graph),
        num_vertices(graph) - num_vertices(graph),
        vertex_index_map
      ),
      make_shared_array_property_map(
        num_vertices(graph),
        boost::detail::get_null_vertex(graph),
        vertex_index_map
      ),
      visitor
    ).first;
  }

#if defined(BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS)
  BOOST_PARAMETER_FUNCTION(
    (
      boost::lazy_enable_if<
        typename mpl::eval_if<
          boost::detail::has_internal_vertex_property_map<
            typename boost::detail::mutable_value_type<
              Args,
              boost::graph::keywords::tag::graph
            >::type,
            vertex_index_t
          >,
          mpl::has_key<Args,boost::graph::keywords::tag::result>,
          mpl::false_
        >::type,
        boost::detail::mutable_value_type<
          Args,
          boost::graph::keywords::tag::result
        >
      >
    ), articulation_points, ::boost::graph::keywords::tag,
    (required
      (graph, *(boost::detail::argument_predicate<is_vertex_list_graph>))
    )
    (deduced
      (required
        (result
          ,*(boost::detail::argument_predicate<boost::detail::is_iterator>)
        )
      )
      (optional
        (discover_time_map
          ,*(
            boost::detail::argument_with_graph_predicate<
              boost::detail::is_vertex_to_integer_map_of_graph
            >
          )
          ,make_shared_array_property_map(
            num_vertices(graph),
            num_vertices(graph) - num_vertices(graph),
            get(vertex_index, graph)
          )
        )
        (predecessor_map
          ,*(
            boost::detail::argument_with_graph_predicate<
              boost::detail::is_vertex_to_vertex_map_of_graph
            >
          )
          ,make_shared_array_property_map(
            num_vertices(graph),
            boost::detail::get_null_vertex(graph),
            get(vertex_index, graph)
          )
        )
        (visitor
          ,*(
            boost::detail::argument_with_graph_predicate<
              boost::detail::is_dfs_visitor
            >
          )
          ,default_dfs_visitor()
        )
      )
    )
    (optional
      (lowpoint_map
        ,*(
          boost::detail::argument_with_graph_predicate<
            boost::detail::is_vertex_to_integer_map_of_graph
          >
        )
        ,make_shared_array_property_map(
          num_vertices(graph),
          num_vertices(graph) - num_vertices(graph),
          get(vertex_index, graph)
        )
      )
    )
  )
#else   // !defined(BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS)
  BOOST_PARAMETER_FUNCTION(
    (
      boost::lazy_enable_if<
        typename mpl::eval_if<
          typename mpl::eval_if<
            boost::detail::is_bgl_named_param_argument<
              Args,
              boost::graph::keywords::tag::discover_time_map
            >,
            mpl::false_,
            boost::detail::has_internal_vertex_property_map<
              typename boost::detail::mutable_value_type<
                Args,
                boost::graph::keywords::tag::graph
              >::type,
              vertex_index_t
            >
          >::type,
          mpl::has_key<Args,boost::graph::keywords::tag::result>,
          mpl::false_
        >::type,
        boost::detail::mutable_value_type<
          Args,
          boost::graph::keywords::tag::result
        >
      >
    ), articulation_points, ::boost::graph::keywords::tag,
    (required
      (graph, *)
      (result, *)
    )
    (optional
      (discover_time_map
        ,*
        ,make_shared_array_property_map(
          num_vertices(graph),
          num_vertices(graph) - num_vertices(graph),
          get(vertex_index, graph)
        )
      )
      (predecessor_map
        ,*
        ,make_shared_array_property_map(
          num_vertices(graph),
          boost::detail::get_null_vertex(graph),
          get(vertex_index, graph)
        )
      )
      (visitor, *, default_dfs_visitor())
      (lowpoint_map
        ,*
        ,make_shared_array_property_map(
          num_vertices(graph),
          num_vertices(graph) - num_vertices(graph),
          get(vertex_index, graph)
        )
      )
    )
  )
#endif  // BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS
  {
    return boost::detail::biconnected_components_impl(
      graph,
      dummy_property_map(),
      result,
      get(vertex_index, graph),
      discover_time_map,
      lowpoint_map,
      predecessor_map,
      visitor
    ).second;
  }

#if defined(BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS)
  BOOST_PARAMETER_FUNCTION(
    (
      boost::lazy_enable_if<
        typename mpl::eval_if<
          boost::detail::has_internal_vertex_property_map<
            typename boost::detail::mutable_value_type<
              Args,
              boost::graph::keywords::tag::graph
            >::type,
            vertex_index_t
          >,
          mpl::false_,
          mpl::has_key<Args,boost::graph::keywords::tag::result>
        >::type,
        boost::detail::mutable_value_type<
          Args,
          boost::graph::keywords::tag::result
        >
      >
    ), articulation_points, ::boost::graph::keywords::tag,
    (required
      (graph, *(boost::detail::argument_predicate<is_vertex_list_graph>))
    )
    (deduced
      (required
        (result
          ,*(boost::detail::argument_predicate<boost::detail::is_iterator>)
        )
        (vertex_index_map
          ,*(
            boost::detail::argument_with_graph_predicate<
              boost::detail::is_vertex_to_integer_map_of_graph
            >
          )
        )
      )
      (optional
        (visitor
          ,*(
            boost::detail::argument_with_graph_predicate<
              boost::detail::is_dfs_visitor
            >
          )
          ,default_dfs_visitor()
        )
      )
    )
  )
#else   // !defined(BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS)
  BOOST_PARAMETER_FUNCTION(
    (
      boost::lazy_enable_if<
        typename mpl::eval_if<
          typename mpl::eval_if<
            boost::detail::is_bgl_named_param_argument<
              Args,
              boost::graph::keywords::tag::vertex_index_map
            >,
            mpl::true_,
            boost::detail::has_internal_vertex_property_map<
              typename boost::detail::mutable_value_type<
                Args,
                boost::graph::keywords::tag::graph
              >::type,
              vertex_index_t
            >
          >::type,
          mpl::false_,
          mpl::has_key<Args,boost::graph::keywords::tag::result>
        >::type,
        boost::detail::mutable_value_type<
          Args,
          boost::graph::keywords::tag::result
        >
      >
    ), articulation_points, ::boost::graph::keywords::tag,
    (required
      (graph, *)
      (result, *)
      (vertex_index_map, *)
    )
    (optional
      (visitor, *, default_dfs_visitor())
    )
  )
#endif  // BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS
  {
    return boost::detail::biconnected_components_impl(
      graph,
      dummy_property_map(),
      result,
      vertex_index_map,
      make_shared_array_property_map(
        num_vertices(graph),
        num_vertices(graph) - num_vertices(graph),
        vertex_index_map
      ),
      make_shared_array_property_map(
        num_vertices(graph),
        num_vertices(graph) - num_vertices(graph),
        vertex_index_map
      ),
      make_shared_array_property_map(
        num_vertices(graph),
        boost::detail::get_null_vertex(graph),
        vertex_index_map
      ),
      visitor
    ).second;
  }
}} // end namespace boost::graph

#else   // !defined(BOOST_GRAPH_CONFIG_CAN_NAME_ARGUMENTS)

#include <boost/functional/value_factory.hpp>

namespace boost { namespace graph { namespace detail {

    template <typename Graph, typename ComponentMap, typename OutputIterator>
    struct biconnected_components_impl
    {
        typedef std::pair<std::size_t, OutputIterator> result_type;
        typedef result_type type;

        template <typename ArgPack>
        inline result_type operator()(
            const Graph& g, ComponentMap comp, OutputIterator out,
            const ArgPack& arg_pack
        ) const
        {
            typename boost::detail::override_const_property_result<
                ArgPack,
                boost::graph::keywords::tag::vertex_index_map,
                vertex_index_t,
                Graph
            >::type v_i_map = boost::detail::override_const_property(
                arg_pack,
                boost::graph::keywords::_vertex_index_map,
                g,
                vertex_index
            );
            typedef typename graph_traits<Graph>::vertices_size_type VSize;
            const VSize no_vertices = VSize();
            boost::detail::make_property_map_from_arg_pack_gen<
                boost::graph::keywords::tag::discover_time_map,
                VSize
            > dtime_map_gen(no_vertices);
            typename boost::detail::map_maker<
                Graph,
                ArgPack,
                boost::graph::keywords::tag::discover_time_map,
                VSize
            >::map_type dtime_map = dtime_map_gen(g, arg_pack);
            boost::detail::make_property_map_from_arg_pack_gen<
                boost::graph::keywords::tag::lowpoint_map,
                VSize
            > lowpt_map_gen(no_vertices);
            typename boost::detail::map_maker<
                Graph,
                ArgPack,
                boost::graph::keywords::tag::lowpoint_map,
                VSize
            >::map_type lowpt_map = lowpt_map_gen(g, arg_pack);
            typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
            boost::detail::make_property_map_from_arg_pack_gen<
                boost::graph::keywords::tag::predecessor_map,
                Vertex
            > pred_map_gen(graph_traits<Graph>::null_vertex());
            typename boost::detail::map_maker<
                Graph,
                ArgPack,
                boost::graph::keywords::tag::predecessor_map,
                Vertex
            >::map_type pred_map = pred_map_gen(g, arg_pack);
            typename boost::remove_const<
                typename parameter::value_type<
                    ArgPack,
                    boost::graph::keywords::tag::visitor,
                    default_dfs_visitor
                >::type
            >::type vis = arg_pack[
                boost::graph::keywords::_visitor ||
                boost::value_factory<default_dfs_visitor>()
            ];
            return boost::detail::biconnected_components_impl(
                g,
                comp,
                out,
                v_i_map,
                dtime_map,
                lowpt_map,
                pred_map,
                vis
            );
        }
    };

    template <typename Graph, typename OutputIterator>
    struct articulation_points_impl
    {
        typedef OutputIterator result_type;
        typedef result_type type;

        template <typename ArgPack>
        inline result_type operator()(
            const Graph& g, OutputIterator result, const ArgPack& arg_pack
        ) const
        {
            typename boost::detail::override_const_property_result<
                ArgPack,
                boost::graph::keywords::tag::vertex_index_map,
                vertex_index_t,
                Graph
            >::type v_i_map = boost::detail::override_const_property(
                arg_pack,
                boost::graph::keywords::_vertex_index_map,
                g,
                vertex_index
            );
            typedef typename graph_traits<Graph>::vertices_size_type VSize;
            const VSize no_vertices = VSize();
            boost::detail::make_property_map_from_arg_pack_gen<
                boost::graph::keywords::tag::discover_time_map,
                VSize
            > dtime_map_gen(no_vertices);
            typename boost::detail::map_maker<
                Graph,
                ArgPack,
                boost::graph::keywords::tag::discover_time_map,
                VSize
            >::map_type dtime_map = dtime_map_gen(g, arg_pack);
            boost::detail::make_property_map_from_arg_pack_gen<
                boost::graph::keywords::tag::lowpoint_map,
                VSize
            > lowpt_map_gen(no_vertices);
            typename boost::detail::map_maker<
                Graph,
                ArgPack,
                boost::graph::keywords::tag::lowpoint_map,
                VSize
            >::map_type lowpt_map = lowpt_map_gen(g, arg_pack);
            typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
            boost::detail::make_property_map_from_arg_pack_gen<
                boost::graph::keywords::tag::predecessor_map,
                Vertex
            > pred_map_gen(graph_traits<Graph>::null_vertex());
            typename boost::detail::map_maker<
                Graph,
                ArgPack,
                boost::graph::keywords::tag::predecessor_map,
                Vertex
            >::map_type pred_map = pred_map_gen(g, arg_pack);
            typename boost::remove_const<
                typename parameter::value_type<
                    ArgPack,
                    boost::graph::keywords::tag::visitor,
                    default_dfs_visitor
                >::type
            >::type vis = arg_pack[
                boost::graph::keywords::_visitor ||
                boost::value_factory<default_dfs_visitor>()
            ];
            return boost::detail::biconnected_components_impl(
                g,
                dummy_property_map(),
                result,
                v_i_map,
                dtime_map,
                lowpt_map,
                pred_map,
                vis
            ).second;
        }
    };
}}} // namespace boost::graph::detail

namespace boost { namespace graph {

    // Boost.Parameter-enabled variants
    BOOST_GRAPH_MAKE_FORWARDING_FUNCTION(biconnected_components, 3, 7)
    BOOST_GRAPH_MAKE_FORWARDING_FUNCTION(articulation_points, 2, 6)

    template <
        typename Graph, typename ComponentMap, typename OutputIterator,
        typename DiscoverTimeMap, typename LowPointMap
    >
    inline typename boost::disable_if<
        parameter::are_tagged_arguments<DiscoverTimeMap, LowPointMap>,
        std::pair<std::size_t, OutputIterator>
    >::type
    biconnected_components(
        const Graph& g, ComponentMap comp, OutputIterator out,
        DiscoverTimeMap dtm, LowPointMap lowpt
    )
    {
        return biconnected_components(
            g, comp, out,
            boost::graph::keywords::_discover_time_map = dtm,
            boost::graph::keywords::_lowpoint_map = lowpt
        );
    }

    template <typename Graph, typename ComponentMap>
    inline std::size_t
    biconnected_components(const Graph& g, ComponentMap comp)
    {
        return biconnected_components(
            g, comp, boost::graph_detail::dummy_output_iterator()
        ).first;
    }
}} // end namespace boost::graph

#endif  // BOOST_GRAPH_CONFIG_CAN_NAME_ARGUMENTS

namespace boost {

    using ::boost::graph::biconnected_components;
    using ::boost::graph::articulation_points;

  template <typename Graph, typename ComponentMap, typename OutputIterator,
      typename P, typename T, typename R>
  std::pair<std::size_t, OutputIterator>
  biconnected_components(const Graph& g, ComponentMap comp, OutputIterator out, 
      const bgl_named_params<P, T, R>& params)
  {
#if defined(BOOST_GRAPH_CONFIG_CAN_NAME_ARGUMENTS) && \
    !(defined(__MINGW32__) && BOOST_WORKAROUND(BOOST_GCC, < 60000))
    typedef bgl_named_params<P, T, R> params_type;
    BOOST_GRAPH_DECLARE_CONVERTED_PARAMETERS(params_type, params)
    return detail::biconnected_components_impl(
      g,
      comp,
      out,
      arg_pack[
        boost::graph::keywords::_vertex_index_map |
        detail::vertex_or_dummy_property_map(g, vertex_index)
      ],
      arg_pack[
        boost::graph::keywords::_discover_time_map |
        make_shared_array_property_map(
          num_vertices(g),
          num_vertices(g) - num_vertices(g),
          arg_pack[
            boost::graph::keywords::_vertex_index_map |
            detail::vertex_or_dummy_property_map(g, vertex_index)
          ]
        )
      ],
      arg_pack[
        boost::graph::keywords::_lowpoint_map |
        make_shared_array_property_map(
          num_vertices(g),
          num_vertices(g) - num_vertices(g),
          arg_pack[
            boost::graph::keywords::_vertex_index_map |
            detail::vertex_or_dummy_property_map(g, vertex_index)
          ]
        )
      ],
      arg_pack[
        boost::graph::keywords::_predecessor_map |
        make_shared_array_property_map(
          num_vertices(g),
          detail::get_null_vertex(g),
          arg_pack[
            boost::graph::keywords::_vertex_index_map |
            detail::vertex_or_dummy_property_map(g, vertex_index)
          ]
        )
      ],
      arg_pack[boost::graph::keywords::_visitor | default_dfs_visitor()]
    );
#else
    typedef typename get_param_type< vertex_discover_time_t, bgl_named_params<P,T,R> >::type dispatch_type;

    return detail::bicomp_dispatch1<dispatch_type>::apply(g, comp, out, 
        choose_const_pmap(get_param(params, vertex_index), g, vertex_index), 
        params, get_param(params, vertex_discover_time));
#endif  // BOOST_GRAPH_CONFIG_CAN_NAME_ARGUMENTS
  }

  template <typename Graph, typename ComponentMap,
      typename P, typename T, typename R>
  inline std::size_t
  biconnected_components(const Graph& g, ComponentMap comp, 
      const bgl_named_params<P, T, R>& params)
  {
    return biconnected_components(g, comp,
        graph_detail::dummy_output_iterator(), params).first;
  }

  template<typename Graph, typename OutputIterator, 
      typename P, typename T, typename R>
  inline OutputIterator
  articulation_points(const Graph& g, OutputIterator out, 
      const bgl_named_params<P, T, R>& params)
  {
    return biconnected_components(g, dummy_property_map(), out, 
        params).second;
  }
} // namespace boost

#endif  /* BOOST_GRAPH_BICONNECTED_COMPONENTS_HPP */
