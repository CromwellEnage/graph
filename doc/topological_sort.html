<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
          "http://www.w3.org/TR/html4/strict.dtd">
<html>
<!--
    Copyright (c) Jeremy Siek 2000

    Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
-->
<head>
<title>Boost Graph Library: Topological Sort</title>
<link rel="stylesheet" type="text/css" href="graph.css" />
</head>
<body>
<img src="../../../boost.png" alt="C++ Boost" width="277" height="86" />

<br />

<h1><a name="sec:topological-sort"></a><img src="figs/python.gif"
alt="(Python)" /><tt>topological_sort</tt></h1>

<h3>Synopsis</h3>

<pre class="cxx_code">
<span class="comment">// old-style named parameter version</span>
template &lt;typename VertexListGraph, typename OutputIterator,
          typename P, typename T, typename R&gt;
void topological_sort(VertexListGraph&amp; graph, OutputIterator result,
    const bgl_named_params&lt;P, T, R&gt;&amp; params = <span class="comment"
>/* all defaults */</span>);
</pre>

<p>If the configuration macro
<span class="cxx_code">BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS</span>
is defined, then the following function overload definition is available.</p>

<pre class="cxx_code">
<a href="../../parameter/doc/html/reference.html#boost-parameter-function-result-name-tag-namespace-arguments">BOOST_PARAMETER_FUNCTION</a>(
    (bool), topological_sort, ::boost::graph::keywords::tag,
    (required
        (graph
          , *(<span class="comment">/* unspecified predicate */</span>)
        )
    )
    (deduced
        (required
            (result
              , *(<span class="comment">/* unspecified predicate */</span>)
            )
        )
        (optional
            (vertex_index_map
              , *(<span class="comment">/* unspecified predicate */</span>)
              , <span class="comment"
>// see parameter table for default value</span>
            )
            (color_map
              , *(<span class="comment">/* unspecified predicate */</span>)
              , <a
href="../../property_map/doc/shared_array_property_map.html"
>make_shared_array_property_map</a>(
                    num_vertices(graph),
                    white_color,
                    vertex_index_map
                )
            )
        )
    )
)
</pre>

<p>If the configuration macro
<span class="cxx_code">BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS</span>
is <strong>not</strong> defined, then the following function overload
definition is available.</p>

<pre class="cxx_code">
<a href="../../parameter/doc/html/reference.html#boost-parameter-function-result-name-tag-namespace-arguments">BOOST_PARAMETER_FUNCTION</a>(
    (bool), topological_sort, ::boost::graph::keywords::tag,
    (required
        (graph, *)
        (result, *)
    )
    (optional
        (vertex_index_map
          , *
          , <span class="comment"
>// see parameter table for default value</span>
        )
        (color_map
          , *
          , <a
href="../../property_map/doc/shared_array_property_map.html"
>make_shared_array_property_map</a>(
                num_vertices(graph),
                white_color,
                vertex_index_map
            )
        )
    )
)
</pre>

<h3><a name="sec:description"></a>Description</h3>

<p>The topological sort algorithm creates a linear ordering of the vertices
such that if edge <i>(u,v)</i> appears in the graph, then <i>v</i> comes
before <i>u</i> in the ordering.  The graph must be a directed acyclic graph
(DAG).  The implementation consists mainly of a call to <a class="cxx_code"
href="depth_first_search.html">depth_first_search()</a>.</p>

<h3><a name="sec:where_defined"></a>Where Defined:</h3>

<p><a href="../../../boost/graph/topological_sort.hpp"
><tt>boost/graph/topological_sort.hpp</tt></a></p>

<h3><a name="sec:parameters"></a>Parameters</h3>

<p>If <strong>any</strong> of the following are true:</p>

<ul>
<li>This document renders the category of a parameter as black text on a white
background.</li>
<li>The configuration macro <span
class="cxx_code">BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS</span> is
<strong>not</strong> defined.</li>
</ul>

<p>Then the argument must be bound to this parameter either by name or by
position.  On the other hand, if <strong>all</strong> of the following are
true:</p>

<ul>
<li>This document renders the category of a parameter as colored text on a
black background.</li>
<li>The configuration macro <span class="cxx_code"
>BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS</span> is defined.</li>
</ul>

<p>Then <a href="../../parameter/doc/html/index.html">Boost.Parameter's</a>
type deduction facilities can bind an unnamed argument to this parameter as
long as <strong>all</strong> of the following are true:</p>

<ul>
<li>The argument type fulfills the parameter type requirements.</li>
<li>The argument's position is the same as that of a parameter whose category
is rendered by this document such that the text is of the same color.</li>
</ul>

<table>
<tr>
<th>Category:</th>
<td>IN</td>
</tr>
<tr>
<th><a href="../../parameter/doc/html/index.html">Boost.Parameter</a>
keyword:</th>
<td class="cxx_code">boost::graph::keywords::_graph</td>
</tr>
<tr>
<th>Unnamed version:</th>
<td class="cxx_code">VertexListGraph&amp; graph</td>
</tr>
<tr>
<th>Description:</th>
<td>A directed acylic graph (DAG).  The graph type must be a model of
<a class="cxx_concept" href="VertexListGraph.html">Vertex List Graph</a> and
<a class="cxx_concept" href="IncidenceGraph.html">Incidence Graph</a>.  If the
graph is not a DAG then a <a class="cxx_code" href="exception.html#not_a_dag"
>not_a_dag</a> exception will be thrown and the user should discard the
contents of the argument to which the <span class="cxx_code"
>boost::graph::keywords::_result</span> parameter is bound.</td>
</tr>
<tr>
<th>Python:</th>
<td>The parameter is named <span class="python_code">graph</span>.</td>
</tr>
<tr>
<td colspan="2"><hr /></td>
</tr>
<tr class="deduced_param_0">
<th>Category:</th>
<td>OUT</td>
</tr>
<tr>
<th><a href="../../parameter/doc/html/index.html">Boost.Parameter</a>
keyword:</th>
<td class="cxx_code">boost::graph::keywords::_result</td>
</tr>
<tr>
<th>Unnamed version:</th>
<td class="cxx_code">OutputIterator result</td>
</tr>
<tr>
<th>Description:</th>
<td>The vertex descriptors of the graph will be output to this argument in
<strong>reverse</strong> topological order.  The argument type must model
<a class="cxx_concept" href="http://www.boost.com/sgi/stl/OutputIterator.html"
>Output Iterator</a>.</td>
</tr>
<tr>
<th>Python:</th>
<td>This parameter is not used in Python.  Instead, a Python
<span class="python_code">list</span> containing the vertices in
topological order is returned.</td>
</tr>
<tr>
<td colspan="2"><hr /></td>
</tr>
<tr class="deduced_param_0">
<th>Category:</th>
<td>IN</td>
</tr>
<tr>
<th><a href="../../parameter/doc/html/index.html">Boost.Parameter</a>
keyword:</th>
<td class="cxx_code">boost::graph::keywords::_vertex_index_map</td>
</tr>
<tr>
<th>Old-style signature:</th>
<td class="cxx_code">vertex_index_map(VertexIndexMap i_map)</td>
</tr>
<tr>
<th>Description:</th>
<td>This maps each vertex to an integer in the half-open range from zero to
the number of vertices in the graph argument.  This parameter is only
necessary when the default color property map is used.  The argument type must
be a model of <a href="../../property_map/doc/ReadablePropertyMap.html"
class="cxx_concept">Readable Property Map</a>.  The value type of the map must
be an integer type.  The vertex descriptor type of the graph needs to be
usable as the key type of the map.</td>
</tr>
<tr valign="top">
<tr>
<th>Default:</th>
<td><span class="cxx_code">get(vertex_index, graph)</span> if the graph has an
internal <span class="cxx_code">vertex_index</span> property, otherwise
<span class="cxx_code">dummy_property_map()</span></td>
</tr>
<tr>
<th>Note:</th>
<td>If this argument is a <span class="cxx_code">dummy_property_map</span>
object, then the color map argument must be specified.  For example, <span
class="cxx_code">adjacency_list</span> with <span class="cxx_code"
>VertexList=listS</span> does not have an internal <span class="cxx_code"
>vertex_index</span> property, so the default value of this argument will be a
<span class="cxx_code">dummy_property_map</span> object.</td>
</tr>
<tr>
<th>Python:</th>
<td>Unsupported parameter.</td>
</tr>
<tr>
<td colspan="2"><hr /></td>
</tr>
<tr class="deduced_param_0">
<th>Category:</th>
<td>UTIL/OUT</td>
</tr>
<tr>
<th><a href="../../parameter/doc/html/index.html">Boost.Parameter</a>
keyword:</th>
<td class="cxx_code">boost::graph::keywords::_color_map</td>
</tr>
<tr>
<th>Old-style signature:</th>
<td class="cxx_code">color_map(ColorMap color)</td>
</tr>
<tr>
<th>Description:</th>
<td>This is used by the algorithm to keep track of its progress through the
graph.  The argument type must be a model of <a class="cxx_concept"
href="../../property_map/doc/ReadWritePropertyMap.html">Read/Write Property
Map</a> and its key type must be the graph's vertex descriptor type and
the value type of the color map must model <a class="cxx_concept"
href="ColorValue.html">ColorValue</a>.</td>
</tr>
<tr>
<th>Default:</th>
<td>A <a href="../../property_map/doc/shared_array_property_map.html"
class="cxx_code">shared_array_property_map</a> of <span class="cxx_code"
>white_color</span> values, and of size <span class="cxx_code"
>num_vertices(graph)</span>, and using the index map argument for the index
map.</td>
</tr>
<tr>
<th>Python:</th>
<td>The color map must be a <span class="python_code">vertex_color_map</span>
for the graph.</td>
</tr>
</table>

<h3><a name="complexity"></a>Complexity</h3>

<p>The time complexity is <i>O(V + E)</i>.</p>

<h3><a name="example"></a>Example</h3>

<p>Calculate a topological ordering of the vertices.</p>

<pre class="cxx_code">
  typedef adjacency_list&lt; vecS, vecS, directedS, color_property&lt;&gt; &gt; Graph;
  typedef boost::graph_traits&lt;Graph&gt;::vertex_descriptor Vertex;
  Pair edges[6] = { Pair(0,1), Pair(2,4),
                    Pair(2,5),
                    Pair(0,3), Pair(1,4),
                    Pair(4,3) };
  Graph G(6, edges, edges + 6);

  typedef std::vector&lt; Vertex &gt; container;
  container c;
  topological_sort(G, std::back_inserter(c));

  cout &lt;&lt; "A topological ordering: ";
  for ( container::reverse_iterator ii=c.rbegin(); ii!=c.rend(); ++ii)
    cout &lt;&lt; index(*ii) &lt;&lt; " ";
  cout &lt;&lt; endl;
</pre>
<p>The output is:</p>
<pre>
  A topological ordering: 2 5 0 1 4 3
</pre>

<br />
<hr />
<table>
<tr>
<td nowrap="nowrap">Copyright &copy; 2000-2001</td>
<td><a href="http://www.boost.org/people/jeremy_siek.htm">Jeremy Siek</a>,
Indiana University (<a
href="mailto:jsiek@osl.iu.edu">jsiek@osl.iu.edu</a>)</td>
</tr>
</table>

</body>
</html> 
