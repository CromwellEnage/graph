<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<!--
    Copyright (c) Jeremy Siek 2000-2001

    Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
-->
<head>
<title>Boost Graph Library: Connected Components</title>
<link rel="stylesheet" type="text/css" href="graph.css" />
</head>
<body>
<img src="../../../boost.png" alt="C++ Boost" width="277" height="86" />

<br />

<h1><a name="sec:connected-components"></a><img src="figs/python.gif"
alt="(Python)" /><tt>connected_components</tt></h1>

<h3>Synopsis</h3>

<pre class="cxx_code">
<span class="comment">// old-style named parameter version</span>
template &lt;class Graph, class ComponentMap, class P, class T, class R&gt;
typename property_traits&lt;ComponentMap&gt;::value_type
connected_components(const Graph&amp; graph, ComponentMap component_map,
    const bgl_named_params&lt;P, T, R&gt;&amp; params = <span class="comment"
>all defaults</span>);

<span class="comment">// there is not a non-named parameter version of this function</span>
</pre>

<p>If the configuration macro
<span class="cxx_code">BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS</span>
is defined, then the following function overload definition is available.</p>

<pre class="cxx_code">
<a href="../../parameter/doc/html/reference.html#boost-parameter-function-result-name-tag-namespace-arguments">BOOST_PARAMETER_FUNCTION</a>(
    (
        boost::lazy_enable_if&lt;
            typename mpl::has_key&lt;
                Args,
                boost::graph::keywords::tag::component_map
            &gt;::type,
            <span class="comment">/*
                unspecified metafunction instantiation that evaluates to
                the value type of component_map
            */</span>
        &gt;
    ), connected_components, ::boost::graph::keywords::tag,
    (required
        (graph
          , *(<span class="comment">/* unspecified predicate */</span>)
        )
        (component_map
          , *(<span class="comment">/* unspecified predicate */</span>)
        )
    )
    (deduced
        (optional
            (vertex_index_map
              , *(<span class="comment">/* unspecified predicate */</span>)
              , <span class="comment"
>// see parameter table for default value</span>
            )
            (color_map
              , *(<span class="comment">/* unspecified predicate */</span>)
              , <a
href="../../property_map/doc/shared_array_property_map.html"
>make_shared_array_property_map</a>(
                    num_vertices(graph),
                    white_color,
                    vertex_index_map
                )
            )
        )
    )
)
</pre>

<p>If the configuration macro
<span class="cxx_code">BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS</span>
is <strong>not</strong> defined, then the following function overload
definition is available.</p>

<pre class="cxx_code">
<a href="../../parameter/doc/html/reference.html#boost-parameter-function-result-name-tag-namespace-arguments">BOOST_PARAMETER_FUNCTION</a>(
    (
        boost::lazy_enable_if&lt;
            <span class="comment">/*
                unspecified metafunction instantiation that evaluates to
                mpl::true_ iff Args contains component_map and
                vertex_index_map is not bound to a bgl_named_params instance
            */</span>,
            <span class="comment">/*
                unspecified metafunction instantiation that evaluates to
                the value type of component_map
            */</span>
        &gt;
    ), connected_components, ::boost::graph::keywords::tag,
    (required
        (graph, *)
        (component_map, *)
    )
    (optional
        (vertex_index_map
          , *
          , <span class="comment"
>// see parameter table for default value</span>
        )
        (color_map
          , *
          , <a
href="../../property_map/doc/shared_array_property_map.html"
>make_shared_array_property_map</a>(
                num_vertices(graph),
                white_color,
                vertex_index_map
            )
        )
    )
)
</pre>

<p>However, for users of Microsoft Visual C++ 14.0 with 64-bit addressing,
only the following function overload definition is available.</p>

<pre class="cxx_code">
<span class="comment">// Boost.Parameter-enabled version</span>
template &lt;
    typename <a class="cxx_concept" href="Graph.html">Graph</a
>, typename ComponentMap,
    typename TaggedArg0, typename TaggedArg1
&gt;
typename <a href="../../property_map/doc/property_map.html">property_traits</a
>&lt;ComponentMap&gt;::value_type connected_components(
    const Graph&amp; graph, ComponentMap component_map,
    const TaggedArg0&amp; a0 = <span class="comment">/* unspecified */</span>,
    const TaggedArg1&amp; a1 = <span class="comment">/* unspecified */</span>,
    typename boost::enable_if&lt;
        parameter::<a
href="../../parameter/doc/html/reference.html#are-tagged-arguments"
>are_tagged_arguments</a>&lt;TaggedArg0, TaggedArg1&gt;,
        mpl::true_
    &gt;::type = mpl::true_()
);
</pre>

<h3><a name="sec:description"></a>Description</h3>

<p>The <span class="cxx_code">connected_components()</span> algorithm computes
the connected components of an undirected graph using a DFS-based approach,
and it returns the total number of connected components.  A <b><i>connected
component</i></b> of an undirected graph is a set of vertices that are all
reachable from each other.  If the connected components need to be maintained
while a graph is growing, then the disjoint-set based approach of function
<a class="cxx_code" href="incremental_components.html"
>incremental_components()</a> is faster.  For ``static'' graphs, this
DFS-based approach is faster [<a href="bibliography.html#clr90">8</a>].</p>

<h3><a name="sec:where_defined"></a>Where Defined</h3>

<p><a href="../../../boost/graph/connected_components.hpp"
><tt>boost/graph/connected_components.hpp</tt></a></p>

<h3><a name="sec:parameters"></a>Parameters</h3>

<p>If <strong>any</strong> of the following are true:</p>

<ul>
<li>This document renders the category of a parameter as black text on a white
background.</li>
<li>The configuration macro <span
class="cxx_code">BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS</span> is
<strong>not</strong> defined.</li>
</ul>

<p>Then the argument must be bound to this parameter either by name or by
position.  On the other hand, if <strong>all</strong> of the following are
true:</p>

<ul>
<li>This document renders the category of a parameter as colored text on a
black background.</li>
<li>The configuration macro <span class="cxx_code"
>BOOST_GRAPH_CONFIG_CAN_DEDUCE_UNNAMED_ARGUMENTS</span> is defined.</li>
</ul>

<p>Then <a href="../../parameter/doc/html/index.html">Boost.Parameter's</a>
type deduction facilities can bind an unnamed argument to this parameter as
long as <strong>all</strong> of the following are true:</p>

<ul>
<li>The argument type fulfills the parameter type requirements.</li>
<li>The argument's position is the same as that of a parameter whose category
is rendered by this document such that the text is of the same color.</li>
</ul>

<table class="parameters">
<tr>
<th>Category:</th>
<td>IN</td>
</tr>
<tr>
<th><a href="../../parameter/doc/html/index.html">Boost.Parameter</a>
keyword:</th>
<td class="cxx_code">boost::graph::keywords::_graph</td>
</tr>
<tr>
<th>Unnamed version:</th>
<td class="cxx_code">const Graph&amp; graph</td>
</tr>
<tr>
<th>Description:</th>
<td>An undirected graph.  Its type must be a model of <a class="cxx_concept"
href="VertexListGraph.html">Vertex List Graph</a> and <a class="cxx_concept"
href="IncidenceGraph.html">Incidence Graph</a>.</td>
</tr>
<tr>
<th>Python:</th>
<td>The parameter is named <span class="python_code">graph</span>.</td>
</tr>
<tr>
<td colspan="2"><hr /></td>
</tr>
<tr class="deduced_param_0">
<th>Category:</th>
<td>OUT</td>
</tr>
<tr>
<th><a href="../../parameter/doc/html/index.html">Boost.Parameter</a>
keyword:</th>
<td class="cxx_code">boost::graph::keywords::_component_map</td>
</tr>
<tr>
<th>Unnamed version:</th>
<td class="cxx_code">ComponentMap component_map</td>
</tr>
<tr>
<th>Description:</th>
<td>The algorithm computes how many connected components are in the graph, and
it assigns each component an integer label.  The algorithm then records which
component each vertex in the graph belongs to by recording the component
number in the component property map.  The argument type must be a model of
<a class="cxx_concept" href="../../property_map/doc/WritablePropertyMap.html"
>Writable Property Map</a>.  The value type must be an integer type,
preferably the same as the type of the number of vertices in the graph.  The
key type must be the graph's vertex descriptor type.</td>
</tr>
<tr>
<th>Python:</th>
<td>Must be an <span class="python_code">vertex_int_map</span> for the graph.</td>
</tr>
<tr>
<th>Python default:</th>
<td class="python_code">graph.get_vertex_int_map("component")</td>
</tr>
<tr>
<td colspan="2"><hr /></td>
</tr>
<tr class="deduced_param_0">
<th>Category:</th>
<td>IN</td>
</tr>
<tr>
<th><a href="../../parameter/doc/html/index.html">Boost.Parameter</a>
keyword:</th>
<td class="cxx_code">boost::graph::keywords::_vertex_index_map</td>
</tr>
<tr>
<th>Old-style signature:</th>
<td class="cxx_code">vertex_index_map(VertexIndexMap i_map)</td>
</tr>
<tr>
<th>Description:</th>
<td>This maps each vertex to an integer in the range <tt>[0, <span
class="cxx_code">num_vertices(graph)</span>)</tt>.  This parameter is only
necessary when the default color property map is used.  The argument type must
be a model of <a href="../../property_map/doc/ReadablePropertyMap.html"
class="cxx_concept">Readable Property Map</a>.  The value type of the map must
be an integer type.  The vertex descriptor type of the graph needs to be
usable as the key type of the map.</td>
</tr>
<tr>
<th>Default:</th>
<td><span class="cxx_code">get(vertex_index, graph)</span> if the graph has an
internal <span class="cxx_code">vertex_index</span> property, otherwise
<span class="cxx_code">dummy_property_map()</span></td>
</tr>
<tr>
<th>Note:</th>
<td>If this argument is a <span class="cxx_code">dummy_property_map</span>
object, then the color map argument must be specified.  For example,
<span class="cxx_code">adjacency_list</span> with <span class="cxx_code"
>VertexList=listS</span> does not have an internal <span class="cxx_code"
>vertex_index</span> property, so the default value of this argument will be a
<span class="cxx_code">dummy_property_map</span> object.</td>
</tr>
<tr>
<th>Python:</th>
<td>Unsupported parameter.</td>
</tr>
<tr>
<td colspan="2"><hr /></td>
</tr>
<tr class="deduced_param_0">
<th>Category:</th>
<td>UTIL</td>
</tr>
<tr>
<th><a href="../../parameter/doc/html/index.html">Boost.Parameter</a>
keyword:</th>
<td class="cxx_code">boost::graph::keywords::_color_map</td>
</tr>
<tr>
<th>Old-style signature:</th>
<td class="cxx_code">color_map(ColorMap color)</td>
</tr>
<tr>
<th>Description:</th>
<td>This is used by the algorithm to keep track of its progress through the
graph.  Its argument type must be a model of <a class="cxx_concept"
href="../../property_map/doc/ReadWritePropertyMap.html">Read/Write Property
Map</a>, its key type must be the graph's vertex descriptor type, and the
value type of the color map must model <a class="cxx_concept"
href="ColorValue.html">ColorValue</a>.</td>
</tr>
<tr>
<th>Default:</th>
<td>A <a href="../../property_map/doc/shared_array_property_map.html"
class="cxx_code">shared_array_property_map</a> of <span class="cxx_code"
>white_color</span> values, and of size <span class="cxx_code"
>num_vertices(graph)</span>, and using the index map argument for the index
map.</td>
</tr>
<tr>
<th>Python:</th>
<td>The color map must be a <span class="python_code">vertex_color_map</span>
for the graph.</td>
</tr>
</table>

<h3><a name="sec:complexity"></a>Complexity</h3>

<p>The time complexity for the connected components algorithm is also
<i>O(V + E)</i>.</p>

<h3><a name="sec:see_also"></a>See Also</h3>

<p><a class="cxx_code" href="strong_components.html">strong_components()</a>
and <a class="cxx_code" href="incremental_components.html"
>incremental_components()</a></p>

<h3><a name="sec:example"></a>Example</h3>

<p>The file <a href="../example/connected_components.cpp"><tt
>examples/connected_components.cpp</tt></a> contains an example of calculating
the connected components of an undirected graph.</p>

<br />
<hr />
<table>
<tr>
<td class="copyright">Copyright &copy; 2000-2001</td>
<td><a href="http://www.boost.org/people/jeremy_siek.htm">Jeremy Siek</a>,
Indiana University
(<a class="external" href="mailto:jsiek@osl.iu.edu">jsiek@osl.iu.edu</a>)</td>
</tr>
</table>

</body>
</html>
